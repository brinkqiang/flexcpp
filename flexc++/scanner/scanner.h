// Generated by Flexc++ v0.7.0~pre on Tue, 23 Mar 2010 10:01:46 +0000

#ifndef SCANNER_H_INCLUDED_
#define SCANNER_H_INCLUDED_

#include <string>
#include <stack>
#include <unordered_map>

#include "../block/block.h"

#include <iosfwd>
#include "scannerbase.h"

// $insert namespace-open

class SemVal;

class Scanner: public ScannerBase
{
    Block   d_block;
    std::stack<StartCondition__> d_fromCondition;

    std::unordered_map<std::string, std::string> d_nameExpansion;
    std::string d_patternName;
    bool d_beginOfPattern;
    bool d_initialClosingBracket;

    public:
        Scanner(std::string const &fname);

        int lex();
        int pLex();     // calls/returns lex(), clears beginOfPattern

        void addDefinition(SemVal const &name, SemVal const &definition);
        void newDefinition();
        void reset(StartCondition__ start);
        Block const &block() const;

    private:
        void begin(StartCondition__ to);
        int begin(StartCondition__ to, int token);
        int end(int token = -1);    // go back to pushed startcondition
                                    // (if any) return token. 

        void preCode();     // re-implement this function for code that must 
                            // be exec'ed before the patternmatching starts

        void pushNameExpansion();
        void maybeSwitchStream();
        bool popStream();
        void setLineTags(std::string const &filename) const;

        int lex__();
        int executeAction__(size_t ruleNr);
};

inline void Scanner::preCode() 
{
    // optionally replace by your own code
}

inline void Scanner::newDefinition()
{
    d_patternName.clear();
}

inline Block const &Scanner::block() const
{
    return d_block;
}

inline int Scanner::lex()
{
    return lex__();
}

// $insert namespace-close


#endif // SCANNER_H_INCLUDED_
