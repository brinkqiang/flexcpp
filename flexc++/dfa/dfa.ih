#include "dfa.h"

#include <iostream>     // TEMPO

#include <ostream>
#include <algorithm>
#include <iomanip>

#include <bobcat/fnwrap>
#include <bobcat/tablelines>
#include <bobcat/align>
#include <bobcat/table>

#include "../rules/rules.h"
#include "../states/states.h"
#include "../ranges/ranges.h"

using namespace std;
using namespace FBB;

inline bool DFA::cmpAccept(size_t left, size_t right, States const &states)
{
    cerr << "St " << left << " = " << states[left].accept() << ", "
            "St " << right << " = " << states[right].accept() << "\n";
    return states[left].accept() < states[right].accept();
}


inline void DFA::translate(DFARow &row, vector<size_t> const &unique)
{
    row.uniqueMap(unique);
}

    // return the index of the DFA row containing 'nextRow'
inline size_t DFA::available(DFARow const &nextRow)
{
    return find(d_row.begin(), d_row.end(), nextRow) - d_row.begin();
}

inline void DFA::fillStartSet(size_t idx, Rules const &rules, StateSet &start)
{
    start.insert(rules[idx].startState());
}

inline void DFA::mergeFinalSet()
{
    for_each(d_row.begin(), d_row.end(), DFARow::mergeFinalSet);
}

