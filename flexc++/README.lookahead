Notation & Terminology:
=======================

Ax:     accept count
++Ax:   accept count, incremented each time this state is reached again
Fx:     Accept count at a final state

pre-A state:  any NFA state before the A0 state
post-A state: any NFA state from/beyond the A0 state

Each post-A state receives an associated Ax value. Example:

                        +-----+
                        |     |
                     a  v  a  |
        a/a+:     1-----2-----3     Notation: 1--a--2--a--3[2] so complex
                        A0    A1              ascii art can be prevented
                                              [2]3 is used to indicate that 
                                                coming from the left a jump
                                                back to 3 is ok, but not 
                                                coming from the right (see
                                                example at rule 2 below)

Rules:
======

    1. From the A0 state, start counting transitions until F is reached.
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        Example:
                a*/aaa  has NFA:    1[2]--a--2[1]--a--3--a--4--a--5
                                              A0      A1    A2    A3
                        and DFA:
                                    ------------------------------
                                            a
                                    ------------------------------
                                    12      123         A0
                                    123     1234        A1  1step
                                    1234    12345       A2  2steps
                                    12345   12345    F->A3  3steps
                                    ------------------------------
        At F: A = 3 (always).


    2. For transitions from F-A to F-A, having pre-A NFA states, keep A
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        Example:
         (a|ab)*/(a|ba)* has NFA:    ------a------       ------a------
                                 1[3]             [1]3[5]              5[3]
                                     --a-- 2 --b--       --b-- 4 --a--
                                                    A0         A1      A0,1,2
                            DFA:
                                    ---------------------
                                             a       b
                                    ---------------------
                                     135    1235       4    F,A0
                                    1235    1235    1345    F,A0  
                                    1345    1235       4    F,A0
                                       4      35            ++A1 (see Rule 3)
                                      35      35       4
                                    ---------------------

    3. Once a DFA state consisting of post-A states is reached, its A count
       is set to the highest A count of its constituent NFA states (and stop
       following DFA transtitions). Once this state is reached, continuously
       increment the A count at each new transition
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        Example: see example 2: the DFA state consisting of NFA state 4 has A
                 count ++A1

Some more examples:
-------------------
                                    ------a------
    a+/(a|ab)+  NFA:    1 --a-- [1]2             4[2]
                                    --a-- 3 --b--
                                 A0       A1     A1,A2

                            DFA:
                                    ---------------------
                                             a       b
                                    ---------------------
                                       1      12
                                      12    1234               A0
                                    1234    1234      24    F->A1
                                      24     234            A1,A2? -> ++A2
                                     234     234      24
                                    ---------------------


        
    a*b*/a*     NFA:    1[2] --a-- [1]2[3] --b-- [2]3[4] --a-- 4[3]
                                                    A0          A1
                            DFA:
                                    ---------------------
                                             a       b
                                    ---------------------
                                    1234    1234     234    A0,F
                                     234      34     234    A0,F
                                      34      34            ++A1,F
                                    ---------------------


    a*/a*       NFA:    1[2] --a-- [1]2[3] --a-- 3[2]                
                                      A0          A1
                            DFA:
                                    -------------
                                             a   
                                    -------------
                                    123     123     A0,F
                                    -------------


    (a|ab)+/a(a|ba)+ has NFA:   ------a------            ------a------
                               1             3[1] --a-- 4             6[4]
                                --a-- 2 --b--            --b-- 5 --a--
                                              A0        A1     A2     A2,3
                            DFA:
                                    ---------------------
                                             a       b
                                    ---------------------
                                       1     123
                                     123    1234     13        A0
                                    1234   12346    135        A1
                                   12346   12346    135     F->A2
                                      13    1234            
                                     135   12346
                                    ---------------------


    (a|ab)+/(a|ba)+ has NFA:    ------a------    ------a------
                               1             [1]3             5[3]
                                --a-- 2 --b--    --b-- 4 --a--
                                              A0       A1     A1,2
                            DFA:
                                    ---------------------
                                             a       b
                                    ---------------------
                                       1     123
                                     123    1235    134         A0
                                    1235    1235    134      F->A1
                                     134    1235      4
                                       4      35              ++A1
                                      35      35      4
                                    ---------------------

Algorithm:
    1. While creating the NFA, count transitions from A0 (as shown in the NFA
       diagrams above  (multiple possibilities: assign the highest count to an
       NFA state).
    2. When creating the DFA, at the A0 states follow the transitions.
        - for DFA states containing pre-A NFA states use the incremented A
          count of the originating DFA state;
          If an F state is reached, transiting from F to F: 
              keep the A-count of the originating DFA state.
        - if a DFA state is reached merely consisting of post-A NFA states:
              set this state's A count to `incrementing' and initialize to the 
              highest A count of the constituing NFA states.


Technical description
=====================

Parsing:
========

    When the parser has detected a rule it calls Rules::add. A Rule object is
added to d_rules, storing begin and and state indices, accept state index (if
available) and action block. Rules::add also stores the association between
the rule's final state and rule index in its d_finalToRule
unordered_map. 

    The rule to which states belong must be available for rules using the LA
operator (see below). Therefore, for those rules Rules::setRuleIndices is
called to assing the State's d_rule field. This d_rule field is not available
for rules not using the LA operator. 

    Rule's constructor:

    If a rule uses the LA operator it visits all its states until reaching the
A-state, storing the states in its d_preAstates vector. Then the same
procedure is followed for the states from the A-state until the final state,
storing these states in its d_postAstates vector.

In dfa/build.cc all active rules are visited to determine the set of states
defining its 1st row. From here the e-closure is determined and all
transitions to new sets of states. For these new sets the e-closures are
also computed, resulting in the eventual DFA as well as a vector containing
the set of states that defined each of the DFA's rows.

    When inspecting transitions each of the states of a set is inspected
calling DFARow::transit. For final states their associated rule indices are
looked up using Rules::ruleFromFinalState.

    Having determined the transitions DFA::build proceeds to remove
implied/identical rows calling DFA::keepUniqueRows. KeepUniqueRows visits each
of the rows of the DFA, and tests whether an existing row has the same
transitions and final state information as the current row. `Same transitions'
means that the transitions of the current (under inspection) row must be
present in an earlier row; Same final state information means that the current
row is a final state for the same rule(s) as the earlier row. In such
situations the current row can be merged with the earlier row, effectively
keeping the earlier row. The (later) row can be removed as transitions from it
are identical to those from the earlier row. This happens, e.g., because the
NFA construction algorithm introduces more empty edges than strictly
necessary, sometimes resulting in additional rows in the DFAs. This happens,
e.g. with a pattern like (a|ab)+/(a|ba)+, producing DFA 
    -------------------------
         a  b   F         A  
        ---------------------
      0  1                   
      1  2  3                
      2  2  3   0:1          
      3  4  5                
      4  2  3   0:2          
      5  6            0:++1  
      6  7  5   0            
      7  7  5   0            
    -------------------------

Rows 6 and 7 are identical, as are rows 2 and 4. For row 4 the (erroneous, if
|TAIL| should be as short as possible) |TAIL| = 2 is shown, resulting from aba
being interpreted as HEAD: 'a' and TAIL: ba. But when |TAIL| should be
minimized aba should be interpreted as HEAD: ab and TAIL a, which should 
result in transitions 0 -> 1 -> 3 -> 2, with |TAIL| = 1. This happens when row
4 is merged to row 2. Having merged the rows, former transitions to the now
removed rows must of course be updated to the merging row. So row 3 must 
transit to 2 when receiving input symbol a. The member shrinkDFA handles the
shrinkage of the DFA. In this example the final DFA becomes:
    -------------------------
         a  b   F         A  
        ---------------------
      0  1                   
      1  2  3                
      2  2  3   0:1          
      3  2  4                
      4  5            0:++1  
      5  5  4   0            
    -------------------------

Now that the DFA has been constructed it's time to compute the A (and F) 
columns. This is done by DFA::processFinAc, called from DFA::build.

processFinAc:

Information about the rules using the LA operator is stored in the
DFARow::d_finAcInfo vector. Each rule using the LA operator is represented in
this vector by a FinAcInfo object. A FinAcInfo object makes available:

    size_t d_rule;  // which LA rule?
    int d_accept;   // accept count at this point or FinAcInfo::PRE_A_STATE
    int d_final;    // FinAcInfo::NOT_FINAL: not a Finalstate
                    // FinAcInfo::FINAL_NOT_SET: undetermined Final state 
                    // accept count
                    // >= 0:  Final state accept count
    bool d_inc;     // incrementing A-state

DFA::processFinAc visits all the FinAcInfo objects of the current row and
processes each of them by calling DFA::processFinAcInfo.

Each rule is only processed once by processsFinAcInfo. So if the same rule is
used in, e.g., different miniscanners or in different DFA states, then the
first occurrence results in its handling. Since a rule, rather than a DFA row,
defines how its HEAD and TAIL are computed there is no need to re-process a
rule once it has been processed. 

Processing consists of the following steps:

    First the accept counts are determined for the NFA states of the
rule. These counts are only determined once per state to prevent continuous
repetition for repetitive patterns like 'a+'. The first state to receive an
accept count is the rule's accept state (for a rule like ab/cd, resulting in
NFA         
            a       b       c       d
        1 ----- 2 ----- 3 ----- 4 ----- 5

this would be state 3). Due to restrictions in the way the LA operator may be
used there's never a repetitive pattern from a post-A state back to a pre-A
state, so accept counts can be determined starting at the NFA's accepting
state. 

before 

DFARow objects 

    [to be continued]



==============================================================================


OLD:
====

Notation and DFA-rules
----------------------

In this description of the LA procedure the following notation and rules are
used: 

    Notation: 
        F - the final state of a pattern. If this state is reached and there
            is no acceptable continuation then the pattern has been
            recognized. This F indication is not needed in the discussion
            below and so it is left out of the examples not needing the F
            state indication.
        A - an Accept-state. By default the F state is the A state. However,
            with the LA operator it occurs earlier in the Regular Expression 
            pattern, which has the syntactic form `pattern '/' pattern'. 


With a rule (possibly consisting of multiple patterns, joined by the
or-operator ('|')) an accept-length (AL) is maintained. Below notations like
++AL are used to indicate operations on the accept-length.
    
    Rules:
        I. At an A state: if (AL == 0) ++AL
       II. At a DFA transition from state X having an accept flag to X: ++AL.

    NFA notations:

        1 -a- 2               - transit from 1 to 2 on a

        1 -a- 2(1)            - transit from 1 to 2 and from 2 back to 1 

        1(2) -a- 2(1) -b- 3   - transit from 1 to 2, empty or on a, and from
                                2 to 1 (empty) and to 3 on b

    These notations allow me to write down NFAs more efficiently than the
traditional (ascii-art) drawings.


Problematic lookahead patterns
------------------------------

While investigating this approach some examples caused problems. E.g.,

        a/a+        (1)
and
        a+/a        (2)


Their minimal (merging empty state transitions) NFA conversions are:

    (1):        1 -a- 2 -a- 3(2)

    (2):        1 -a- 2(1) -a- 3

Now their DFAs are:

    (1):                                (2)                         
            -----------                         -----------         
                    a                                   a           
            -----------                         -----------         
            1       2                           1       12          
            2       23      A                   12      123     A   
            23      23      A,F                 123     123     A,F 
            -----------                         -----------         

    Comparing these DFAs it becomes clear that they are equal: three rows,
transitions on 'a', A and F rows at the same location. So how then, can we
distinguish (1) from (2)? 

    The solution is found in ASU's simple remark that a '/' operator returns
in the NFA as an empty transition. Let's do the NFA constructions again:

        a/a+        (1)
and
        a+/a        (2)


The NFA conversions are:

    (1):        1 -a- 2 - 3 -a- 4(3)

                The important thing to note here is that the A-state is the 
                {23} set.

    (2):        1 -a- 2(1) - 3 -a- 4
    
                Again, the {23} set represents the A-state.

In our DFA's the A-rows MUST have states 23. Here they are:


  (1): a/a+                           (2) a+/a                    
            -----------                       -------------       
      row            a                  row           a           
            -----------                       -------------       
       1    1       23                   1    1       123         
       2    23      34      A            2    123     1234     A  
       3    34      34      F            3    1234    1234     A,F
            -----------                       -------------       

It's interesting to note that now the DFA's are indeed different.


So, how to they behave? Below I'll use the following notation, numbers
referring to DFA rows:

    -------------
    1 a 2 b 3 c 3       - start at 1, on a to 2, on b to 3 on c to 3
    -------------
        A   A   A       - rows 2 and 3 represent A-states    
        1   1   2       - the A length value
    -------------
        I       II      - applied rules
    -------------

Let's feed 'aaa' to (1) and (2) and see what they produce:

    (1): a/a+                           (2): a+/a
            --------------                      --------------
            1 a 2 a 3 a 3                       1 a 2 a 3 a 3
            --------------                      --------------
                A                                   A   A   A
                1                                   1       2
            --------------                      --------------
                I                                   I       II
            --------------                      --------------
    F is reached, a is returned, aa     F is reached. aa is returned, a 
    is read again                       is read again



Inheriting and non-inheriting accept states
-------------------------------------------

However, we're not out of problems yet. Consider:
    
    a/a*        (3)

    NFA:    1 -a- 2 - 3(4) -a- 4(3)

    DFA: (3): a/a*
            -----------  
      row            a 
            -----------  
       1    1       234
       2    234     234      A,F
            -----------  

Now feed this aaa
            --------------
            1 a 2 a 2 a 2 
            --------------
                A   A   A
                1   2   3
            --------------
                I   II  II
            --------------

This clearly doesn't work, and that's why the distinction between `inheriting'
and `non-inheriting' accept states is introduced. A non-inheriting accept
state is used only in a DFA where a row's set of states contains the NFA's
accept state, an inheriting accept state is, once set, set for all the DFA's
remaining rows as well. The rules with non-inheriting accept states are:

    Rules:
        I. At an A state: if (AL == 0) ++AL
       II. At a DFA transition from state X having an accept flag to X: 
            only once do ++AL.
            ~~~~~~~~~

The addition to rule II means that we'll need two kind of flags in our DFA's,
indicating inheriting and non-inheriting accept states. This doesn't introduce
implementation problems and so below I'll only use A-flags, as the context
unambiguously clarifies whether we talk about inheriting or non-inheriting
accept states.

To find inheriting accept states we start by taking the empty lookahead
transition seriously when creating the NFA. To do this we define a pseudo
input L to transit from the pre-lookahead pattern to the post-lookahead
pattern. With a/a* and a+/a we get, respectively:


  (1): a/a*                           (2) a+/a

    1 -a- 2 -L- 3(4) -a- 4(3)             1 -a- 2(1) -L- 3 -a- 4
              
    Pseudo DFAs      
            --------------                    -------------       
      row            a  L               row           a    L      
            --------------                    -------------       
       1    1        2                   1    1       12          
       2 A  2           34               2 A  12      12   3      
       3 F  34       34                  3    3       4            
            --------------               4 F  4       
                                              -------------       
    2 is the accept state,              2 is the accept state
    3 is the final state.               4 is the final state.

This thing to note here are the accept rows (rows 2): With a/a* (1) it
contains a mere L transition, with a+/a (2) it contains an L transition and a
character transition. This is used to distinguish non-inheriting accept states
from inheriting accept states. When an accept state merely shows a L
transition it is non-inheriting, otherwise it's inheriting.  a/a* gets a
non-inheriting accept state, a+/a an inheriting accept state.


From pseudo DFA to real DFA's
-----------------------------

Of course the pseudo DFAs aren't `true' DFAs, since there is no such thing
like an L-character. Let's proceed by merging rows 2 and 3 of the above pseudo
DFAs to get rid of the L transitions, and at the same time propagate a+/a's
inheriting accept state:

    DFA:    a/a+                        a+/a
            --------------                     -------------       
      row            a                  row            a           
            --------------                     -------------       
       1    1        23                  1     1       123         
       2 A  23       34                  2 A   123     1234        
       3 F  34       34                  3 A,F 1234    1234         
            --------------                     -------------
    2 is the accept state,              2 is the accept state
    3 is the final state.               3 is the final state.

Now feed aaaa to both DFAs and see what happens:

    -----------------                   -----------------    
    1 a 2 a 3 a 3 a 3                   1 a 2 a 3 a 3 a 3    
    -----------------                   -----------------    
        A                                   A   A   A   A           
        1                                   1       2   3    
    --------------                      -----------------    
        I                                   I       II  II   
    --------------                      ------------------   
    a is returned, aaa is               aaa is returned, a is
    read again                          read again           


Now we do this again for, e.g., a+/aap

NFA:  1 -a- 2(1) -L- 3 -a- 4 -a- 5 -p- 6

Pseudo DFA:                         real DFA:
      -------------------------       ------------------------     
      row              a  L  p        row             a      p      
              -----------------               ----------------     
       1      1        12              1      1       123          
       2 A    12       12 3            2 A    123     1234         
       3 A    3        4               3 A    1234    12345         
       4 A    4              5         4 A    12345   12345  6
       5 A,F  5                        5 A,F  6                    
       ------------------------        ------------------------
    2 is the accept state,          2 is the inheriting accept state
    3 is the final state.           5 is the final state.

Feeding aaaaap we get:
           ~~~
        -------------------------
        1 a 2 a 3 a 4 a 4 a 4 p 5   numbers are row-numbers in the DFA
            A   A   A   A   A   A
            1           2   3
        -------------------------
    We accept aaa and return aap



Applying the OR-operator
------------------------

Here's a pattern using an or-operator:

    (a|ab)/b+
              ----a----    
    NFA:    1            3 -L- 4 -b- 5(4)
              -a- 2 -b-

    Pseudo DFA:
        -----------------------
                    a   b   L
                  -------------
               1    23
               23       3   4
             A 3            4
               4        45
             F 45       45
        -----------------------

Since the accept state line only has the L transition, it's a non-inheriting
accept state. But note that state 3 is the accept state, so there are two rows
in the following DFA having the A flag, as these states contain the accept
state A. The DFA thus becomes:

    DFA:
       --------------
              a    b 
            ---------
          1   234
      A 234       345
    F,A 345       345
       --------------

Feeding ab we get:
        
            ----------
            1 a 2 b 3
                A   A
                1
            ----------
    accept a, reread b

Feeding abbb we get:
        
        -----------------
        1 a 2 b 3 b 3 b 3 
            A   A   A   A
            1       2
        -----------------
    accept ab, reread bb


Easy determination of the inheriting nature of accept states
------------------------------------------------------------

In fact the pseudo DFA doesn't have to be constructed to determine whether an
accept state is inheriting or not. In the state-array, if a accept state
has multiple transitions emanating from it is is inheriting, otherwise it is
non-inheriting. 

Some example:

a/a+:       1 -a- 2 - 3 -a- 4(3)        2 is the accept state, non-inheriting

a+/a:       1 -a- 2(1) - 3 -a- 4        2 is the accept state, inheriting

a/a*:       1 -a- 2 - 3(4) -a- 4(3)     2 is the accept state. non-inheriting

a+/aap:     1 -a- 2(1) - 3 -a- 4 -a- 5 -p- 6
                                        2 is the accept state, non-inheriting

(a|ab)/b+     ----a----                 3 is the accept state, non-inheriting
            1            3 - 4 -b- 5(4)
              -a- 2 -b-                  

20/04
=====

The initialization of the count is not from 0 to 1 but from 0 to the length
of the match so-far.

21/04
=====

Revision:

Each rule has an Accept struct (at each new start initialized to -1 values) 
associated with it;

    struct Accept
    {
        int length;
        int acceptLength;
    };

Using the update procedure described below, the 'length' field will contain
the length of the match up to the look-forward operator, while 'acceptLength'
is set to the length of the match buffer at an Accept state.

DFA transtions may step forward (to a higher state number) or step backward
(to the same or a previous state number.  Updates are only performed at the
first-reached accept state and with backward steps.

Two types of updates are used:
    1. when the struct's length field equals -1 then length and acceptLength
are set to the length of the contents of the current match buffer (d_match).
    2. otherwise the difference between the match length and the
acceptLength's value is added to the length field whereafter the current match
buffer length is assigned to acceptLength.

============================================================================

New approach, 24/4/2010.

Below  these range nrs are used:     

        a = 1, p = 3, q = 4     (no `b' is used)
        a = 1, b = 2, p = 4, q = 5 

In a pattern HEAD/TAIL |HEAD| is the length of the head, |TAIL| is the length
of the tail. Only one of these is required to compute the actual match length
and the length of the lookahead string to be pushed back.

Types of LA patterns
====================

First: what patterns can be distinguished? When discussing cases * is used to
indicate the generic repetition (it can be *, ?, +, {x,})

Pattern: a*/b       Here |TAIL| has a fixed length. No need to search when 
                    actual input is matched.

Pattern: a/b*       Here |HEAD| has a fixed length. No need to search
    
Pattern: a*/b*      Here the transition from a to b marks |HEAD|. This isn't
                    known in advance, so a means must be developed to pick up
                    that point. In fact it's easy, as the / is recognized as
                    the A (accept) state in the DFA. Example:

                    Pattern: a+/b+
                    DFA:
                    -------------------
                         1  2   F   A  
                         --------------
                      0  1             
                      1  1  2       0  
                      2     2   0      
                    -------------------

Pattern: p*a/a*q*   This is `problem type 1'. The TAIL has variable size, and
                    repeats the last part of the HEAD. Neither HEAD nor TAIL
                    has a fixed size, so no pre-computation is possible. But
                    as the HEAD's end is well marked (by A) its size becomes
                    readily available when the DFA is run (examples follow)

Pattern: p*a*/aq*   This is `problem type 2'. The HEAD has variable size and
                    the tail repeats the last part of the HEAD. Here the
                    problem is that you don't know that you're in the TAIL
                    until you're in the TAIL.... Before that we were in the
                    HEAD, and so remembering |HEAD| at A allows us to set
                    |HEAD| at any point in the TAIL (examples follow)

Problem type 1:
===============

Pattern: pa/a?q

----------------------
     1  3  4   F   A  
     -----------------
  0     1             
  1  2                
  2  3     4       0  
  3        4          
  4            0      
----------------------

Pattern: pa/a+q

----------------------
     1  3  4   F   A  
     -----------------
  0     1             
  1  2                
  2  3             0  
  3  3     4          
  4            0      
----------------------

Pattern: pa/a*q

----------------------
     1  3  4   F   A  
     -----------------
  0     1             
  1  2                
  2  3     4       0  
  3  3     4          
  4            0      
----------------------


For these patterns: at A(ccept) lines: the match length == |HEAD|

Example: consider pattern p+(ab)/(ab)+q*
DFA:
-------------------------
     1  2  4  5   F   A  
     --------------------
  0        1             
  1  2     1             
  2     3                
  3  4                0  
  4     5                
  5  4        6   0      
  6           6   0      
-------------------------

Input:
    p p a b a b a b q q    
                                        A
                0 -p- 1 -p- 1 -a- 2 -b- 3 -a- 4 -b- 5 -a- 4 -b- 5 -q- 6 -q- 6
|match|         0     1     2     3     4     5     6     7     8     9     10
|HEAD|     -1                           4

Conclusion: |HEAD| is 4, |TAIL| is 6.




Problem Type 2.
===============

Pattern type: pa?/aq
====================

Pattern: pa?/aq

----------------------
     1  3  4   F   A  
     -----------------
  0     1             
  1  2             0  
  2  3     4       0  
  3        4          
  4            0      
----------------------

Pattern: p(ab)?/abq

-------------------------
     1  2  4  5   F   A  
     --------------------
  0        1             
  1  2                0  
  2     3                
  3  4        5       0  
  4     6                
  5               0      
  6           5          
-------------------------


Pattern type: pa+/aq
====================

Pattern: pa+/aq
----------------------
     1  3  4   F   A  
     -----------------
  0     1             
  1  2                
  2  3             0  
  3  3     4       0  
  4            0      
----------------------

Pattern: p(ab)+/(ab)q

-------------------------
     1  2  4  5   F   A  
     --------------------
  0        1             
  1  2                   
  2     3                
  3  4                0  
  4     5                
  5  4        6       0  
  6               0      
-------------------------



Pattern type: pa*/aq
====================

Pattern: pa*/aq

----------------------
     1  3  4   F   A  
     -----------------
  0     1             
  1  2             0  
  2  2     3       0  
  3            0      
----------------------

Pattern: p(ab)*/abq

-------------------------
     1  2  4  5   F   A  
     --------------------
  0        1             
  1  2                0  
  2     3                
  3  2        4       0  
  4               0      
-------------------------


For these patterns: At A: save matchsize, set |HEAD| at the next A state


Consider p(ab)+/abq and input:
    p a b a b a b q

                          A           A           A           A
                    0 -p- 1 -a- 2 -b- 3 -a- 2 -b- 3 -a- 2 -b- 3 -q- 5
|match|             0     1     2     3     4     5     6     7     8
saved |match| -1          1           3           5           7
|HEAD|        -1         -1           1           3           5

Conclusion: |HEAD| is 5, |TAIL| is 3.

Now input:    p a b q
                          A           A  
                    0 -p- 1 -a- 2 -b- 3 -q- 5
|match|             0     1     2     3     4
saved |match| -1          1           3   
|HEAD|        -1         -1           1   

Conclusion: |HEAD| is 1, |TAIL| is 3.



Implementing LA length recogition
=================================

What to do?

    - Flexc++'s parser keeps track of patters as being of types 1 or 2. That's
      easily done. Problem types 1 have 1 accept state for its rules, problem
      types 2 have 2 (And patterns without LA have 0 accept states)

    - When an accept state is reached the procedure appropriate for the
      problem type is used: |HEAD| is set (once) for problem types 1, |HEAD|
      is set to the last saved |HEAD|, and save-headlength is set to |HEAD|
      for problem types 2.

    - For each rule the lex function is provided with info about the rule's 
      type, and |HEAD| is updated accordingly for rules of problem types 1 and
      2. Rules without LA pattern simply use the unmodified matched text.

Conjecture: 

    Some DFA's have identical A-lines. In those cases the HEAD length is
computed as d_match.size().

Consider the following patterns and their DFA's:

    a+/a+                       (ab)+/(ab)+              
        ------------------          ---------------------
             1   F     A                 1  2   F     A  
             -------------               ----------------
          0  1                        0  1               
          1  2       0-V              1     2            
          2  2   0   0-V              2  3          0-V  
        ------------------            3     4            
                                      4  3      0   0-V  
                                    ---------------------


    a+/a*                       (ab)+/(ab)*              
        ------------------          ---------------------
             1   F     A                 1  2   F     A  
             -------------               ----------------
          0  1                        0  1               
          1  2   0   0-V              1     2            
          2  2   0   0-V              2  3      0   0-V  
        ------------------            3     4            
                                      4  3      0   0-V  
                                    ---------------------


    a*/a+                       (ab)*/(ab)+              
        ------------------          ---------------------
             1   F     A                 1  2   F     A  
             -------------               ----------------
          0  1       0-V              0  1          0-V  
          1  1   0   0-V              1     2            
        ------------------            2  1      0   0-V  
                                    ---------------------

    
    a*/a*                       (ab)*/(ab)*              
        ------------------          ---------------------
             1   F     A                 1  2   F     A  
             -------------               ----------------
          0  1   0   0-V              0  1      0   0-V  
          1  1   0   0-V              1     2            
        ------------------            2  1      0   0-V  
                                    ---------------------

And the somewhat more complex:

    y+(ab)*/(ab)*c*
        ---------------------------
             1  2  3  5   F     A  
             ----------------------
          0           1            
          1  2     3  1   0   0-V  
          2     4                  
          3        3      0        
          4  2     3      0   0-V  
        ---------------------------

and

    y+(ab)*/(ab)*c*d

        ------------------------------
             1  2  3  4  6   F     A  
             -------------------------
          0              1            
          1  2     3  4  1       0-V  
          2     5                     
          3        3  4               
          4                  0        
          5  2     3  4          0-V  
        ------------------------------

New Approach
============

Richard and Jean-Paul pinpointed several weaknesses in the above algorithm,
related to patterns having variable lenghts HEAD and TAILS and to patterns
using the alternative- (or-) operator.

Here is another attempt to crack the LA problem:

Consider patterns having fixed-length TAILs. It's either possible to determine
the tail's length compile time or to compute the tail's length as the
`shortest path' from the A state to the F state. Even though this hasn't been
implemented at this point, fixed-length tail patterns should remain out of the
discussion. Similarly, patterns with fixed length HEADs offer no problems and
are left out of the discusion.

This leaves us with variable length tails and heads. In this approach the
focus is on |TAIL|, not anymore on |HEAD|.


Richard made a valuable remark: the tail is always the shortest match. What's
the shortest match? The distance from A to F. So let's concentrate on this and
see what happens.

Consider 
        a*/aaaa+

which represents one of Richard's counter examples to the earlier
procedure. Below, the input characters are left out of the diagrams, since
they're not relevant. The DFA for this pattern is:

        ------------------
             1   F     A  
             -------------
          0  1       0-V  
          1  2       0-V  
          2  3       0-V  
          3  4       0-V  
          4  4   0   0-V  
        ------------------

Consider the `shortest path' from A to F: 

        0   1   2   3   4

Its length is 4, and so after matching aaaaaaaaaaaaaaaaaa the final 4
characters are to be re-read and the rest is matched.            

Now consider 

        a*/aaaa*

which is a slight modification. DFA is:

        ------------------
             1   F     A  
             -------------
          0  1       0-V  
          1  2       0-V  
          2  3       0-V  
          3  4   0   0-V  
          4  4   0   0-V  
        ------------------
        
Shortest path:  

        0   1   2   3

Thus, |TAIL| == 3.

Another example for which the previous algorithm failed was. 

        p(ab)*/ababq

This pattern is trivial, though, as its tail has a fixed length. Nevertheless,
here's its DFA:

        ---------------------------
             1  2  4  5   F     A  
             ----------------------
          0        1               
          1  2                0-V  
          2     3                  
          3  4                0-V  
          4     5                  
          5  4        6       0-V  
          6               0        
        ---------------------------

    Its diagram is:

                    +---+
                    V   |
    0   1   2   3   4   5   6
        A       A       A   F

    The shortest path starts (as always) at A, so it is

        1   2   3   4   5   6, and |TAIL| == 5.

Let's turn this pattern into a variable length TAIL:

        p(ab)*/ab(ab)+q

It has the same DFA (!) as the fixed pattern, so |TAIL| == 5.
OK, so let's do 

        p(ab)*/ab(ab)*q

This one has DFA:

        ---------------------------
             1  2  4  5   F     A  
             ----------------------
          0        1               
          1  2                0-V  
          2     3                  
          3  4        5       0-V  
          4     6                  
          5               0        
          6  4        5       0-V  
        ---------------------------

The diagram is:     +---+
                    V   |
                    4---6 A
                  /      \ 
    0   1   2   3----------5
        A       A           F

    Shortest path:  1   2   3   5, with |TAIL| == 3, as it should be

      
Let's do:
    
    ab*/b*c

DFA is:
        ------------------------
             1  2  3   F     A  
             -------------------
          0  1                  
          1     2  3   0   0-V  
          2     2  3   0   0-V  
          3        3   0        
        ------------------------

    Diagram:
                   +--+
                   V  |
              +--- 2--+
              |    |A
        0   1 +    |       
            A |    V
              +--- 3
                   F

    Shortest path:  1   3, so |TAIL| == 1.


Now these:

    b*/b*                   b*/b+
------------------          ------------------
     1   F     A                 1   F     A  
     -------------               -------------
  0  1   0   0-V              0  1       0-V  
  1  1   0   0-V              1  1   0   0-V  
------------------          ------------------
                                              
Diagrams:
        ---+                    ---+
        V  |                    V  |
    0---1--+                0---1--+
    FA  FA                  A   FA  

DFAs are identical, but there is a difference: at b*/b* state 0 is also F.

If our initial state is FA, we start counting (as usual) at 0, but we're
immediately in the final state, so 0 steps for the tail and |TAIL| == 0
This handles b*/b*.

For b*/b+ we apply the normal shortest path procedure: From 0 (A) to 1 (F) is
1 step, so for b*/b+ |TAIL| == 1.


Now alternatives:

Consider a|ab/ba|a
DFA:
    ---------------------
         1  2   F     A  
         ----------------
      0  1               
      1  2  3       0-V  
      2         0        
      3  4  5       0-V  
      4         0        
      5  6               
      6         0        
    ---------------------

Since we have alternatives, we have alternative paths. Consider the complete
transition diagram (with chars showing the required inputs for the
transitions): 

       a       a
    0-----1-+----- 2F
          A |            a
            +----- 3 -+----- 4F
               b   A  |    
                      +----- 5 ----- 6F
                         b       a

So at 1 the shortest path to 2 is 1 step; if that's not reached, then at
3 the shortest path is reset, becoming 1 if aba is matched at 4 and 2 if abba
is matched at 6.

The branches here are not resulting from repetitions but from alternatives. So
the accept states must be handled accordingly: 1 is A only for 2, 3 is A for 4
or 6.

Now combine repetitions with alternatives:

                a*|(ab)*/(ab)*ba+|a+

DFA:

    -----------------------
          1   2   F     A  
         ------------------
      0   1   2       0-V  
      1   3   4   0   0-V  
      2   5                
      3   3   6   0   0-V  
      4   7   2       0-V  
      5   5       0        
      6   8   2            
      7   9  10   0        
      8   5  11   0        
      9   9       0        
     10  12   2       0-V  
     11  13   2            
     12  14  10   0        
     13      11            
     14  14       0        
    -----------------------

Drawing the diagram we get:

               +----+
               V    |                                          +------------+
 0 +-a- 1 +-a- 3 -a-+                              F           V            |
 A |    A |    A -b- 6 -------+-a----------------- 8 ----+--b- 11 -a- 13 -b-+
   |    F |    F              +-b------------------+     |        -b->2
   |      |                                        |     |
   |      |                +----+                  |     |
   |      |                V    |                  |     |
   |      +-b- 4 +a- 7 +a- 9 -a-+                  |     |
   |           A |   F |   F                       |     |
   |             |     |   +------------+          |     |
   |             |     |   |            |  +----+  |     |
   |             |     |   V      F  +b-+  V    |  |     |
   |             |     +b- 10 +a- 12 +a-- 14 -a-+  |     |
   |             +b--+     A  +b-+         F       |     |
   |                 |           |                 |     |      +----+
   |                 |           |                 |     |      V    |
   +-b--- -----------+-----------+-----------------+- 2 -+---a- 5 -a-+
                                                                F

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

All this doesn't work smoothly, unfortunately...
So we do a completely different approach.

The problem with all these LA situations is always that we don't know where to
end the HEAD and to begin the TAIL. 

So let's tackle the problem from there. In all cases where there is a clearly
recognizable begin of the tail we're sure that the tail starts. Example:

    (b*|(ab)*)/x(b*|(ab*))

Results in 
------------------------
     1  2  4   F     A  
     -------------------
  0  1  2  3       0-V  
  1     4               
  2     2  3       0-V  
  3  5  6      0        
  4  1     3       0-V  
  5     7      0        
  6     6      0        
  7     7      0        
------------------------

We can forget about the A states, and concentrate on input cat. 4, which is
'x'. Once we see 'x' we move to a second section of the DFA, from where
there's no way back to the first section. Of course there isn't a route back
since we've reached the tail. 

Until we're at range 4 ('x') we remain in the head and therefore by noting the
point where we matched 'x' we known where the tail starts. 

Works fine, also with previously problematic patterns like b*/b* ('x' is input
cat. 3 here):

---------------------
     1  3   F     A  
     ----------------
  0  1  2       0-V  
  1  1  2       0-V  
  2  3      0        
  3  3      0        
---------------------

Passing this one a series of b's they will all be matched by the DFA's first
part and the tail is (as it should) as short as possible. 

Hm... unfortunately this doesn't work either since we don't know where the
tail starts when it requires one character. a*/xa works fine with a real x,
but if x is a pseudo character we don't know where it is. 

But on the other hand: we *do* know where the tail starts. So we know the
tail's length? Again we don't: a*/xa* produces
---------------------
     1  3   F     A  
     ----------------
  0  1  2       0-V  
  1  1  2       0-V  
  2  3      0        
  3  3      0        
---------------------
and there's no way to determine either the head or the tail's length from the
DFA or from actually running the DFA if x isn't a real but a pseudo character
like EOF or BOL.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

So, once again: what to do? LA patterns are only a problem if the head's last
term continues in the tail's first term(s). As we saw from the previous
section if there's a separating character then the DFA allows us to recognize
the tail's begin (or head's end). Also, patterns not having an variable length
never cause a problem. fixed-length/variable-length or
variable-length/fixed-length allow us to precompute |HEAD| or |TAIL|,
respectively, and we're done for those patterns.

So the problem patterns are: variable-length/variable-length, with the head's
last term repeating as the tail's first. Examples:

    ab*/b+                          ab+/b*
---------------------           ---------------------
     1  2   F     A                  1  2   F     A  
     ----------------                ----------------
  0  1                            0  1               
  1     2       0-V               1     2            
  2     2   0   0-V               2     3   0   0-V  
---------------------             3     3   0   0-V  
                                ---------------------

However, as Richard suggested, we can rewrite such patterns knowing that the
head is always as long as possible. So if the head's end is repeated in the
tail's begin (including situations like b*/bbb+ where the head's final term b
is repeated 3 times) we can apply rewriting rules:

    a*/a*       -> a*               (no tail anymore)
    a*/a+       -> a                (no tail anymore)
    a*/a?       -> a                (no tail anymore)
    a*/a{x,*}   -> a*/a{x}          |TAIL| = |a{x}|

    a+/a*       -> a+               (no tail anymore)
    a+/a+       -> a+/a             |TAIL| = 1
    a+/a?       -> a+               (no tail anymore)
    a+/a{x,*}   -> a+/a{x}          |TAIL| = |a{x}|

    a?/a*       -> a?/a*            |TAIL| = max(0, |match| - 1)
    a?/a+       -> a?/a+            |TAIL| = |match| - 1
    a?/a?       -> a?/a?            |TAIL| = max(0, |match| - 1)
    a?/a{x,*}   -> a*/a{x}          |TAIL| = |a{x}|

    a{x,*}/a*       -> a{x,*}       (no tail anymore)
    a{x,*}/a+       -> a{x,*}/a     |TAIL| = 1
    a{x,*}/a?       -> a{x,*}       (no tail anymore)
    a{x,*}/a{x,*}   -> a{x,*}/a{x}  |TAIL| = |a{x}|

When alternatives are used, (the | operator) the same considerations
apply. However, a pattern may be partially overlapping, as in:

        a+|b+/a+|b+

Here the matching patterns are:

    1   a+/a+
    2   a+/b+
    3   b+/a+
    4   b+/b+

and I think it's hard to rewrite some of the patterns (a+/a+ -> a+/a) and not
others (b+/a+). Here is the DFA:
---------------------
     1  2   F     A  
     ----------------
  0  1  2            
  1  3  4       0-V  
  2  5  6       0-V  
  3  3  4   0   0-V  
  4     4   0        
  5  5      0        
  6  5  6   0   0-V  
---------------------

Could we break up such patterns in parts, copying the action rules? So instead
of a+b+/a+|b+ we would define:

    b+/(a+|b)
    a+/(b+|a)

with eventual DFA:
---------------------
     1  2   F     A  
     ----------------
  0  1  2            
  1  3  4       1-V  
  2  5  6       0-V  
  3  3  4   1   1-V  
  4     4   1        
  5  5      0        
  6  5  6   0   0-V  
---------------------

Receiving a series of a (range 1) chars, we would do:

    0   1   3   3   3   3 

and for 3 we would have registered |TAIL| = 1

Receiving a series of a chars, then a series of b chars would yield:

    0   1   3   3   4   4   4   4
        A   FA  FA  F   F   F   F

The |TAIL| is computed from the last A, so  3   4   4   4   4
                                            FA  F   F   F   F
                                            0   1   2   3   4

We would ALWAYS compute |TAIL| from the last A, but some rules would have
their own A-length set by the compiler, considering that, e.g., a+/a has
|TAIL| 1.

Couldn't we do that for the combined DFA?
---------------------
     1  2   F     A  
     ----------------
  0  1  2            
  1  3  4       0-V  
  2  5  6       0-V  
  3  3  4   0   0-V  
  4     4   0        
  5  5      0        
  6  5  6   0   0-V  
---------------------

A series of a (range 1) chars yields:

    0   1   3   3   3   3
        A   AF  AF  AF  AF

It's the same sequence as earlier, and so yes, we could have assigned |TAIL| 1
to state 3. What about a chars followed by b chars? Here it is:

    0   1   3   3   4   4   4
        A   AF  AF  F   F   F

And again, when leaving 3 the |TAIL| length is reset and counting starts:

    0   1   3   3   4   4   4
        A   AF  AF  F   F   F
                0   1   2   3

It's not implemented yet, but that's probably a minor detail. 
Reactions?

=======================================================================

Yet another approach....

Computational rules: 

    As usual:   xA: state x is an Accepting state
                A: Accept count, xF: final state, y: another state

    At the initial xA: A = 0
        
    Beyond/from A: x -> y, and y > x: ++A
                   x -> y, and y < x: --A

    at xFA: when input stops: use A as accept count
            when input continues: use the last-used A count

    |-operators: split into separate rules, call the same action blocks for
    these rules

Richard's last `killing pattern':

    a*b*/a* has DFA
         1  2   F      A  
         -----------------      
      0  1  2   0   0-V,        input:  
      1  1  2   0   0-V,            0 a 1 a 1 a 1
      2  3  2   0   0-V,            AF  AF  AF  AF  : AF: A = 0, stays 0.
      3  3      0
                                    0 a 1 b 2 a 3 a 3
                                    AF  AF  AF  F   F
                                A:  0   0   0   1   2       |TAIL| = 2

Now consider ab*/b+ and ab+/b*

    ab*/b+                          ab+/b*
---------------------           ---------------------
     1  2   F     A                  1  2   F     A  
     ----------------                ----------------
  0  1                            0  1               
  1     2       0-V               1     2            
  2     2   0   0-V               2     3   0   0-V  
---------------------             3     3   0   0-V  
                                ---------------------

Input: a b b b b

With ab*/b+

    0   a   1   b   2   b   2   b   2   b   2
            A       AF      AF      AF      AF
A:          0       1       1       1       1       |TAIL| = 1

With  ab+/b*
   
    0   a   1   b   2   b   3   b   3   b   3
                    AF      AF      AF      AF
A:                  0       0       0       0       |TAIL| = 0

Let's enlarge the tail:

ab*/bbbb+ DFA:
----------------------
     1  2   F      A  
     -----------------
  0  1                
  1     2       0-V,  
  2     3       0-V,  
  3     4       0-V,  
  4     5       0-V,  
  5     5   0   0-V,  
----------------------
                        --------------------------------------------------
    Input a b b b b b:  0   a   1   b   2   b   3   b   4   b   5   b   5
                                A       A       A       A       AF      AF
                                0       1       2       3       4       4
                        --------------------------------------------------

Let's do some elements of the rewriting table, and see what happens with input
aaa

    a*/a*
-------------------         input: aaa
     1   F      A  
     --------------         0   a   1   a   1   a   1
  0  1   0   0-V,           AF      AF      AF      AF      -> tail = 0
  1  1   0   0-V,  
-------------------

    a*/a+
-------------------
     1   F      A  
     --------------         0   a   1   a   1   a   1   a   1
  0  1       0-V,           A       AF      AF      AF      AF
  1  1   0   0-V,           0       1       1       1       1   -> tail = 1
-------------------

    a*/a? - same DFA as a*/a* -> tail = 0

    a+/a*
-------------------     From row 1 identical to a*/a*'s DFA, so tail = 0
     1   F      A  
     --------------
  0  1             
  1  2   0   0-V,  
  2  2   0   0-V,  
-------------------

Now do some alternatives:

a|ab/ba|a

This results in:
a/ba
a/a
ab/ba
ab/a

DFA:
----------------------------
     1  2   F            A  
     -----------------------
  0  1                      
  1  2  3         0-F,1-F,  
  2         1               
  3  4  5         2-F,3-F,  
  4         0,3             
  5  6                      
  6         2               
----------------------------

the interesting input is of course aba since it matches alternative 0 and
3. See what happens:

    0       1       2       3       |match|
    --------------------------
    0   a   1   b   3   a   4
            0A      2A      0F    
            1A      3A      3F
------------------------------
0A          0       1       2
3A                  0       1

Note that there are various rules playing a role here, but at 4 only rules 0
and 3 count. 0's A is 2, with HEAD size 1, 3's A is 1, with HEAD size
2. Consequently, rule 3 is (correctly) accepted as it has the longer head
length.


Another one of Richard's famous patterns:

a*/(ab)* having DFA:

----------------------
     1  2   F      A  
     -----------------
  0  1      0   0-V,  
  1  1  2   0   0-V,  
  2  3      0         
  3     2             
----------------------

Some inputs: aaa, aaab, abab

    0   a   1   a   1   a   1
    AF      AF      AF      AF      |TAIL| = 0

    0   a   1   a   1   a   1   b   2
    AF      AF      AF      AF      F
    0       0       0       1       2       ...
