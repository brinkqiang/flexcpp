Notation and DFA-rules
----------------------

In this description of the LA procedure the following notation and rules are
used: 

    Notation: 
        F - the final state of a pattern. If this state is reached and there
            is no acceptable continuation then the pattern has been
            recognized. This F indication is not needed in the discussion
            below and so it is left out of the examples not needing the F
            state indication.
        A - an Accept-state. By default the F state is the A state. However,
            with the LA operator it occurs earlier in the Regular Expression 
            pattern, which has the syntactic form `pattern '/' pattern'. 


With a rule (possibly consisting of multiple patterns, joined by the
or-operator ('|')) an accept-length (AL) is maintained. Below notations like
++AL are used to indicate operations on the accept-length.
    
    Rules:
        I. At an A state: if (AL == 0) ++AL
       II. At a DFA transition from state X having an accept flag to X: ++AL.

    NFA notations:

        1 -a- 2               - transit from 1 to 2 on a

        1 -a- 2(1)            - transit from 1 to 2 and from 2 back to 1 

        1(2) -a- 2(1) -b- 3   - transit from 1 to 2, empty or on a, and from
                                2 to 1 (empty) and to 3 on b

    These notations allow me to write down NFAs more efficiently than the
traditional (ascii-art) drawings.


Problematic lookahead patterns
------------------------------

While investigating this approach some examples caused problems. E.g.,

        a/a+        (1)
and
        a+/a        (2)


Their minimal (merging empty state transitions) NFA conversions are:

    (1):        1 -a- 2 -a- 3(2)

    (2):        1 -a- 2(1) -a- 3

Now their DFAs are:

    (1):                                (2)                         
            -----------                         -----------         
                    a                                   a           
            -----------                         -----------         
            1       2                           1       12          
            2       23      A                   12      123     A   
            23      23      A,F                 123     123     A,F 
            -----------                         -----------         

    Comparing these DFAs it becomes clear that they are equal: three rows,
transitions on 'a', A and F rows at the same location. So how then, can we
distinguish (1) from (2)? 

    The solution is found in ASU's simple remark that a '/' operator returns
in the NFA as an empty transition. Let's do the NFA constructions again:

        a/a+        (1)
and
        a+/a        (2)


The NFA conversions are:

    (1):        1 -a- 2 - 3 -a- 4(3)

                The important thing to note here is that the A-state is the 
                {23} set.

    (2):        1 -a- 2(1) - 3 -a- 4
    
                Again, the {23} set represents the A-state.

In our DFA's the A-rows MUST have states 23. Here they are:


  (1): a/a+                           (2) a+/a                    
            -----------                       -------------       
      row            a                  row           a           
            -----------                       -------------       
       1    1       23                   1    1       123         
       2    23      34      A            2    123     1234     A  
       3    34      34      F            3    1234    1234     A,F
            -----------                       -------------       

It's interesting to note that now the DFA's are indeed different.


So, how to they behave? Below I'll use the following notation, numbers
referring to DFA rows:

    -------------
    1 a 2 b 3 c 3       - start at 1, on a to 2, on b to 3 on c to 3
    -------------
        A   A   A       - rows 2 and 3 represent A-states    
        1   1   2       - the A length value
    -------------
        I       II      - applied rules
    -------------

Let's feed 'aaa' to (1) and (2) and see what they produce:

    (1): a/a+                           (2): a+/a
            --------------                      --------------
            1 a 2 a 3 a 3                       1 a 2 a 3 a 3
            --------------                      --------------
                A                                   A   A   A
                1                                   1       2
            --------------                      --------------
                I                                   I       II
            --------------                      --------------
    F is reached, a is returned, aa     F is reached. aa is returned, a 
    is read again                       is read again



Inheriting and non-inheriting accept states
-------------------------------------------

However, we're not out of problems yet. Consider:
    
    a/a*        (3)

    NFA:    1 -a- 2 - 3(4) -a- 4(3)

    DFA: (3): a/a*
            -----------  
      row            a 
            -----------  
       1    1       234
       2    234     234      A,F
            -----------  

Now feed this aaa
            --------------
            1 a 2 a 2 a 2 
            --------------
                A   A   A
                1   2   3
            --------------
                I   II  II
            --------------

This clearly doesn't work, and that's why the distinction between `inheriting'
and `non-inheriting' accept states is introduced. A non-inheriting accept
state is used only in a DFA where a row's set of states contains the NFA's
accept state, an inheriting accept state is, once set, set for all the DFA's
remaining rows as well. The rules with non-inheriting accept states are:

    Rules:
        I. At an A state: if (AL == 0) ++AL
       II. At a DFA transition from state X having an accept flag to X: 
            only once do ++AL.
            ~~~~~~~~~

The addition to rule II means that we'll need two kind of flags in our DFA's,
indicating inheriting and non-inheriting accept states. This doesn't introduce
implementation problems and so below I'll only use A-flags, as the context
unambiguously clarifies whether we talk about inheriting or non-inheriting
accept states.

To find inheriting accept states we start by taking the empty lookahead
transition seriously when creating the NFA. To do this we define a pseudo
input L to transit from the pre-lookahead pattern to the post-lookahead
pattern. With a/a* and a+/a we get, respectively:


  (1): a/a*                           (2) a+/a

    1 -a- 2 -L- 3(4) -a- 4(3)             1 -a- 2(1) -L- 3 -a- 4
              
    Pseudo DFAs      
            --------------                    -------------       
      row            a  L               row           a    L      
            --------------                    -------------       
       1    1        2                   1    1       12          
       2 A  2           34               2 A  12      12   3      
       3 F  34       34                  3    3       4            
            --------------               4 F  4       
                                              -------------       
    2 is the accept state,              2 is the accept state
    3 is the final state.               4 is the final state.

This thing to note here are the accept rows (rows 2): With a/a* (1) it
contains a mere L transition, with a+/a (2) it contains an L transition and a
character transition. This is used to distinguish non-inheriting accept states
from inheriting accept states. When an accept state merely shows a L
transition it is non-inheriting, otherwise it's inheriting.  a/a* gets a
non-inheriting accept state, a+/a an inheriting accept state.


From pseudo DFA to real DFA's
-----------------------------

Of course the pseudo DFAs aren't `true' DFAs, since there is no such thing
like an L-character. Let's proceed by merging rows 2 and 3 of the above pseudo
DFAs to get rid of the L transitions, and at the same time propagate a+/a's
inheriting accept state:

    DFA:    a/a+                        a+/a
            --------------                     -------------       
      row            a                  row            a           
            --------------                     -------------       
       1    1        23                  1     1       123         
       2 A  23       34                  2 A   123     1234        
       3 F  34       34                  3 A,F 1234    1234         
            --------------                     -------------
    2 is the accept state,              2 is the accept state
    3 is the final state.               3 is the final state.

Now feed aaaa to both DFAs and see what happens:

    -----------------                   -----------------    
    1 a 2 a 3 a 3 a 3                   1 a 2 a 3 a 3 a 3    
    -----------------                   -----------------    
        A                                   A   A   A   A           
        1                                   1       2   3    
    --------------                      -----------------    
        I                                   I       II  II   
    --------------                      ------------------   
    a is returned, aaa is               aaa is returned, a is
    read again                          read again           


Now we do this again for, e.g., a+/aap

NFA:  1 -a- 2(1) -L- 3 -a- 4 -a- 5 -p- 6

Pseudo DFA:                         real DFA:
      -------------------------       ------------------------     
      row              a  L  p        row             a      p      
              -----------------               ----------------     
       1      1        12              1      1       123          
       2 A    12       12 3            2 A    123     1234         
       3 A    3        4               3 A    1234    12345         
       4 A    4              5         4 A    12345   12345  6
       5 A,F  5                        5 A,F  6                    
       ------------------------        ------------------------
    2 is the accept state,          2 is the inheriting accept state
    3 is the final state.           5 is the final state.

Feeding aaaaap we get:
           ~~~
        -------------------------
        1 a 2 a 3 a 4 a 4 a 4 p 5   numbers are row-numbers in the DFA
            A   A   A   A   A   A
            1           2   3
        -------------------------
    We accept aaa and return aap



Applying the OR-operator
------------------------

Here's a pattern using an or-operator:

    (a|ab)/b+
              ----a----    
    NFA:    1            3 -L- 4 -b- 5(4)
              -a- 2 -b-

    Pseudo DFA:
        -----------------------
                    a   b   L
                  -------------
               1    23
               23       3   4
             A 3            4
               4        45
             F 45       45
        -----------------------

Since the accept state line only has the L transition, it's a non-inheriting
accept state. But note that state 3 is the accept state, so there are two rows
in the following DFA having the A flag, as these states contain the accept
state A. The DFA thus becomes:

    DFA:
       --------------
              a    b 
            ---------
          1   234
      A 234       345
    F,A 345       345
       --------------

Feeding ab we get:
        
            ----------
            1 a 2 b 3
                A   A
                1
            ----------
    accept a, reread b

Feeding abbb we get:
        
        -----------------
        1 a 2 b 3 b 3 b 3 
            A   A   A   A
            1       2
        -----------------
    accept ab, reread bb


Easy determination of the inheriting nature of accept states
------------------------------------------------------------

In fact the pseudo DFA doesn't have to be constructed to determine whether an
accept state is inheriting or not. In the state-array, if a accept state
has multiple transitions emanating from it is is inheriting, otherwise it is
non-inheriting. 

Some example:

a/a+:       1 -a- 2 - 3 -a- 4(3)        2 is the accept state, non-inheriting

a+/a:       1 -a- 2(1) - 3 -a- 4        2 is the accept state, inheriting

a/a*:       1 -a- 2 - 3(4) -a- 4(3)     2 is the accept state. non-inheriting

a+/aap:     1 -a- 2(1) - 3 -a- 4 -a- 5 -p- 6
                                        2 is the accept state, non-inheriting

(a|ab)/b+     ----a----                 3 is the accept state, non-inheriting
            1            3 - 4 -b- 5(4)
              -a- 2 -b-                  

20/04
=====

The initialization of the count is not from 0 to 1 but from 0 to the length
of the match so-far.

21/04
=====

Revision:

Each rule has an Accept struct (at each new start initialized to -1 values) 
associated with it;

    struct Accept
    {
        int length;
        int acceptLength;
    };

Using the update procedure described below, the 'length' field will contain
the length of the match up to the look-forward operator, while 'acceptLength'
is set to the length of the match buffer at an Accept state.

DFA transtions may step forward (to a higher state number) or step backward
(to the same or a previous state number.  Updates are only performed at the
first-reached accept state and with backward steps.

Two types of updates are used:
    1. when the struct's length field equals -1 then length and acceptLength
are set to the length of the contents of the current match buffer (d_match).
    2. otherwise the difference between the match length and the
acceptLength's value is added to the length field whereafter the current match
buffer length is assigned to acceptLength.

============================================================================

New approach, 24/4/2010.

Below  these range nrs are used:     

        a = 1, p = 3, q = 4     (no `b' is used)
        a = 1, b = 2, p = 4, q = 5 

In a pattern HEAD/TAIL |HEAD| is the length of the head, |TAIL| is the length
of the tail. Only one of these is required to compute the actual match length
and the length of the lookahead string to be pushed back.

Types of LA patterns
====================

First: what patterns can be distinguished? When discussing cases * is used to
indicate the generic repetition (it can be *, ?, +, {x,})

Pattern: a*/b       Here |TAIL| has a fixed length. No need to search when 
                    actual input is matched.

Pattern: a/b*       Here |HEAD| has a fixed length. No need to search
    
Pattern: a*/b*      Here the transition from a to b marks |HEAD|. This isn't
                    known in advance, so a means must be developed to pick up
                    that point. In fact it's easy, as the / is recognized as
                    the A (accept) state in the DFA. Example:

                    Pattern: a+/b+
                    DFA:
                    -------------------
                         1  2   F   A  
                         --------------
                      0  1             
                      1  1  2       0  
                      2     2   0      
                    -------------------

Pattern: p*a/a*q*   This is `problem type 1'. The TAIL has variable size, and
                    repeats the last part of the HEAD. Neither HEAD nor TAIL
                    has a fixed size, so no pre-computation is possible. But
                    as the HEAD's end is well marked (by A) its size becomes
                    readily available when the DFA is run (examples follow)

Pattern: p*a*/aq*   This is `problem type 2'. The HEAD has variable size and
                    the tail repeats the last part of the HEAD. Here the
                    problem is that you don't know that you're in the TAIL
                    until you're in the TAIL.... Before that we were in the
                    HEAD, and so remembering |HEAD| at A allows us to set
                    |HEAD| at any point in the TAIL (examples follow)

Problem type 1:
===============

Pattern: pa/a?q

----------------------
     1  3  4   F   A  
     -----------------
  0     1             
  1  2                
  2  3     4       0  
  3        4          
  4            0      
----------------------

Pattern: pa/a+q

----------------------
     1  3  4   F   A  
     -----------------
  0     1             
  1  2                
  2  3             0  
  3  3     4          
  4            0      
----------------------

Pattern: pa/a*q

----------------------
     1  3  4   F   A  
     -----------------
  0     1             
  1  2                
  2  3     4       0  
  3  3     4          
  4            0      
----------------------


For these patterns: at A(ccept) lines: the match length == |HEAD|

Example: consider pattern p+(ab)/(ab)+q*
DFA:
-------------------------
     1  2  4  5   F   A  
     --------------------
  0        1             
  1  2     1             
  2     3                
  3  4                0  
  4     5                
  5  4        6   0      
  6           6   0      
-------------------------

Input:
    p p a b a b a b q q    
                                        A
                0 -p- 1 -p- 1 -a- 2 -b- 3 -a- 4 -b- 5 -a- 4 -b- 5 -q- 6 -q- 6
|match|         0     1     2     3     4     5     6     7     8     9     10
|HEAD|     -1                           4

Conclusion: |HEAD| is 4, |TAIL| is 6.




Problem Type 2.
===============

Pattern type: pa?/aq
====================

Pattern: pa?/aq

----------------------
     1  3  4   F   A  
     -----------------
  0     1             
  1  2             0  
  2  3     4       0  
  3        4          
  4            0      
----------------------

Pattern: p(ab)?/abq

-------------------------
     1  2  4  5   F   A  
     --------------------
  0        1             
  1  2                0  
  2     3                
  3  4        5       0  
  4     6                
  5               0      
  6           5          
-------------------------


Pattern type: pa+/aq
====================

Pattern: pa+/aq
----------------------
     1  3  4   F   A  
     -----------------
  0     1             
  1  2                
  2  3             0  
  3  3     4       0  
  4            0      
----------------------

Pattern: p(ab)+/(ab)q

-------------------------
     1  2  4  5   F   A  
     --------------------
  0        1             
  1  2                   
  2     3                
  3  4                0  
  4     5                
  5  4        6       0  
  6               0      
-------------------------



Pattern type: pa*/aq
====================

Pattern: pa*/aq

----------------------
     1  3  4   F   A  
     -----------------
  0     1             
  1  2             0  
  2  2     3       0  
  3            0      
----------------------

Pattern: p(ab)*/abq

-------------------------
     1  2  4  5   F   A  
     --------------------
  0        1             
  1  2                0  
  2     3                
  3  2        4       0  
  4               0      
-------------------------


For these patterns: At A: save matchsize, set |HEAD| at the next A state


Consider p(ab)+/abq and input:
    p a b a b a b q

                          A           A           A           A
                    0 -p- 1 -a- 2 -b- 3 -a- 2 -b- 3 -a- 2 -b- 3 -q- 5
|match|             0     1     2     3     4     5     6     7     8
saved |match| -1          1           3           5           7
|HEAD|        -1         -1           1           3           5

Conclusion: |HEAD| is 5, |TAIL| is 3.

Now input:    p a b q
                          A           A  
                    0 -p- 1 -a- 2 -b- 3 -q- 5
|match|             0     1     2     3     4
saved |match| -1          1           3   
|HEAD|        -1         -1           1   

Conclusion: |HEAD| is 1, |TAIL| is 3.



Implementing LA length recogition
=================================

What to do?

    - Flexc++'s parser keeps track of patters as being of types 1 or 2. That's
      easily done. Problem types 1 have 1 accept state for its rules, problem
      types 2 have 2 (And patterns without LA have 0 accept states)

    - When an accept state is reached the procedure appropriate for the
      problem type is used: |HEAD| is set (once) for problem types 1, |HEAD|
      is set to the last saved |HEAD|, and save-headlength is set to |HEAD|
      for problem types 2.

    - For each rule the lex function is provided with info about the rule's 
      type, and |HEAD| is updated accordingly for rules of problem types 1 and
      2. Rules without LA pattern simply use the unmodified matched text.
