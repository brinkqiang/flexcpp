includefile(include/header)

COMMENT(manpage, section, releasedate, archive, short name)
manpage(scanner)(3flexc++)(_CurYrs_)(libbobcat1-dev__CurVers_-x.tar.gz)
                    (Scanner class interface)

manpagename(scanner)(Default scanner class interface generated by flexc++)

manpagesynopsis()
    bf(#include "scanner.h")nl()

manpagedescription()

    By default, flc() generates a file tt(scanner.h) containing the initial
interface of the scanner class performing the lexical scan according to the
specifications given in flc()'s input file. The name of the file that is
generated can easily be changed using flc()'s tt(--class-header)
option. In this man-page we'll stick to using the default name.

    The file tt(scanner.h) is generated only once, unless an explicit request
is made to rewrite it (using flc()'s tt(--force-class-header) option).

    The provided interface is very light-weight, primarily offering a link to
the scanner's base class (see bf(scannerbase)(3flexc++).

    Many of the facilities offered by the scanner class derive from this base
class, and the reader should consult bf(scannerbase)(3flexc++) for further
details about additional elements of the scanner's interface.

manpagesection(NAMING CONVENTION)

    All symbols that are required by the generated scanner class end in two
consecutive underscore characters (e.g., tt(executeAction__)). These names
should not be redefined. As they are part of the tt(Scanner) and
tt(ScannerBase) class their scope is immediately clear and confusion with
identically named identifiers elsewhere is not to be expected. 

    Some member functions do not use the underscore convention. These are the
scanner class's constructors, or names that are similar or equal to names that
have historically been used (e.g., tt(length)). Also, some functions are
offered offering hooks into the implementation (like tt(preCode)). The latter
category of function also have names that don't end in underscores.

manpagesection(CONSTRUCTORS)

    itemization(
    itb(explicit Scanner(std::istream &in = std::cin, 
                    std::ostream &out = std::cout))
        This constructor by default reads information from the standard input
stream and writes to the standard output stream. By providing alternate
streams either input or input and output streams can be altered. When the
tt(Scanner) object goes out of scope the input and output files are closed.
    itb(Scanner(std::string const &infile, std::string const &outfile))
        This constructor opens the input and output streams whose file names
were specified. When the tt(Scanner) object goes out of scope the input and
output files are closed. If tt(outfile == "-") then the standard output stream
will be used as the scanner's output medium. This constructor is not
implemented with interactive scanners.
    )
    
manpagesection(PUBLIC MEMBER FUNCTION)

    itemization(
    itb(int lex())
        The tt(lex) function performs the lexical scanning of the input file
specified at construction time (but also see bf(scannerbase)(3flexc++) for
information about intermediate stream-switching facilities). It returns and
tt(int) representing the em(token) associated with the matched regular
expression. The returned value 0 indicates end-of-file. Considering its
default implementation, it could be redefined by the user. tt(Lex)'s default
implementation merely calls tt(lex__):
        verb(
inline int Scanner::lex()
{
    return lex__();
}
        )
        With interactive scanners the tt(lex) function is defined in the
generated tt(lex.cc) file. See the bf(flexc++)(1) man page for details.
    )

manpagesection(PRIVATE MEMBER FUNCTIONS)

    itemization(
    itb(int lex__())
        This function is used internally by tt(lex) and should not otherwise
be used.
    itb(int executeAction__())
        This function is used internally by tt(lex) and should not otherwise
be used.
    itb(void preCode())
        By default this function has an empty, inline implementation in
tt(scanner.h). It can safely be replaced by a user-defined
implementation. This function is called just before tt(lex__) retrieves the
next character from the input stream. The outline of tt(lex__)'s
implementation looks like this:
        verb(
int Scanner::lex__()
{
    ...
    preCode();

    while (true)
    {
        size_t ch = get__();            // fetch next char
        ...
        switch (actionType__(range))    // determine the action
        {
            ... maybe return
        }
        ... no return, continue scanning
        preCode();
    } // while
}
        )
    )
    
manpagesection(EXAMPLE)

        verb(
#ifndef Scanner_H_INCLUDED_
#define Scanner_H_INCLUDED_

// $insert baseclass_h
#include "scannerbase.h"


class Scanner: public ScannerBase
{
    public:
        explicit Scanner(std::istream &in = std::cin, 
                    std::ostream &out = std::cout);
        
        Scanner(std::string const &infile, std::string const &outfile);

        // $insert lexFunctionDecl
        int lex();

    private:
        int lex__();
        int executeAction__(size_t ruleNr);

        void preCode(); // re-implement this function for code to be
                        // exec'ed before the pattern matching starts
};

inline void Scanner::preCode() 
{
    // optionally replace by your own code
}

inline Scanner::Scanner(std::istream &in, std::ostream &out)
:
    ScannerBase(in, out)
{}

inline Scanner::Scanner(std::string const &infile, 
                                            std::string const &outfile)
:
    ScannerBase(infile, outfile)
{}

// $insert inlineLexFunction
inline int Scanner::lex()
{
    return lex__();
}

#endif // Scanner_H_INCLUDED_
        )


manpageseealso()

    bf(flexc++)(1), bf(input)(3flexc++),  bf(rules)(3flexc++),  
    bf(scannerbase)(3flexc++), 

manpagebugs()
    None Reported.

includefile(include/trailer)
