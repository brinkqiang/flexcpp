    manpagesection(1. QUICK START)

    A bare-bones, no-frills scanner is generated as follows:

    itemization(
    it() Create a file tt(lexer) defining the regular expressions to
recognize, and the tokens to return. Use token values exceeding 0xff if plain
ascii character values can also be used as token values. Example (assume
capitalized words are token-symbols defined in an enum defined by the scanner
class):
        verb(
%%
[ \t\n]+                            // skip white space chars.
[0-9]+                              return NUMBER;
[[:alpha:]_][[:alpha:][:digit:]_]*  return IDENTIFIER;
.                                   return matched()[0];
        )

    it() Execute:
        verb(
    flexc++ lexer
        )
    This generates four files):tt(Scanner.h, Scanner.hh, Scannerbase.h), and
tt(lex.cc) 

    it() Edit tt(Scanner.h), add the enum defining the token-symbols in
(usually) the public section of the class tt(Scanner). E.g.,
        verb(
class Scanner: public ScannerBase
{
    public:
        enum Tokens
        {
            IDENTIFIER = 0x100,
            NUMBER
        };
    // ... (etc, as generated by flexc++)
        )

    it() Create a file defining tt(int main), e.g.:
        verb(
#include <iostream>
#include "Scanner.h"

using namespace std;

int main()
{
    Scanner scanner;        // define a Scanner object

    while (int token = scanner.lex())   // get all tokens
    {
        string const &text = scanner.matched();
        switch (token)
        {
            case Scanner::IDENTIFIER:
                cout << "identifier: " << text << '\n';
            break;

            case Scanner::NUMBER:
                cout << "number: " << text << '\n';
            break;

            default:
                cout << "char. token: `" << text << "'\n";
            break;
        }
    }
}
        )
    it() Compile all tt(.cc) files:
        verb(
    g++ --std=c++11 *.cc
        )
    
    it() To `tokenize' tt(main.cc), execute:
        verb(
    a.out < main.cc
        )
    )

    manpagesection(2. QUICK START: FLEXC++ and BISONC++)

To interface flc() to the bf(bisonc++)(1) parser generator proceed as follows:
    itemization(
    it() Specify a grammar that can be processed by bf(bisonc++)(1). Assuming
that the scanner and parser are developed in, respectively, the
sub-directories tt(scanner) and tt(parser), then a simple grammar
specification that can be used with the scanner developed in the previous
section is, e.g., write the file tt(parser/grammar):
        verb(
%scanner                ../scanner/Scanner.h
%scanner-token-function d_scanner.lex()

%token IDENTIFIER NUMBER CHAR

%%

startrule:
    startrule tokenshow
|
    tokenshow
;

tokenshow:
    token
    {
        std::cout << "matched: " << d_scanner.matched() << '\n';
    }
;

token:
    IDENTIFIER
|
    NUMBER
|
    CHAR
;
    )
    it() Write a scanner specification file. E.g.,
    verb(
%%

[ \t\n]+                            // skip white space chars.
[0-9]+                              return Parser::NUMBER;
[[:alpha:]_][[:alpha:][:digit:]_]*  return Parser::IDENTIFIER;
.                                   return Parser::CHAR;
    )
    This causes the scanner to  return tt(Parser) tokens to the generated
parser. 

    it() Add the line
    verb(
#include "../parser/Parserbase.h"
    )
    to the file tt(scanner/Scanner.hh)

    it() Write a simple tt(main) function in the file tt(main.cc). E.g.,
    verb(
#include "parser/Parser.h"

int main(int argc, char **argv)
{
    Parser parser;

    parser.parse();
}
    )
    
    it() Generate a scanner in the tt(scanner) subdirectory:
    verb(
flexc++ lexer
    )
    
    it() Generate a parser in the tt(parser) subdirectory:
    verb(
bisonc++ grammar
    )
    
    it() Compile all sources:
    verb(
g++ --std=c++0x *.cc */*.cc
    )

    it() Execute the program, providing it some source file to be processed:
    verb(
a.out < main.cc
    )
        )

    manpagesection(3. GENERATED FILES)

Flc() generates four files from a well-formed input file:
    itemization(

    it() A file containing the implementation of the tt(lex) member function
and its support functions. By default this file is named tt(lex.cc).

    it() A file containing the scanner's class interface. By default this file
is named tt(Scanner.h). The scanner class itself is generated once and is
thereafter `owned' by the programmer, who may change it em(ad-lib). Newly
added members (data members, function members) will survive future flc() runs
as flc() will never rewrite an existing scanner class interface file, unless
explicitly ordered to do so. 

    it() A file containing the interface of the scanner class's em(base
class). The scanner class is publicly derived from this base class. It is used
to minimize the size of the scanner interface itself. The scanner base class
is `owned' by bf(flexc++) and should never be hand-modified. By
default the scanner's base class is provided in the file
tt(Scannerbase.h). At each new flc() run this file is rewritten unless flc()
is explicitly ordered em(not) to do so.

    it() A file containing the em(implementation header). This file should
contain includes and declarations that are only required when compiling the
members of the scanner class. By default this file is named
tt(Scanner.hh). This file, like the file containing the scanner class's
interface is never rewritten by flc() unless flc() is explicitly ordered to do
so.
    )

manpagesection(4. PRECOMPILED HEADERS)

    Starting with flc() version 2.04.00 the default extension of internal
header files changed from tt(.ih) to tt(.hh). This simplifies the construction
of em(precompiled headers), which in turn noticeably speeds up the compilation
of source files. 

    Flc()'s own compilation uses precompiled headers for all its classes, which
reduces flc()'s compilation time by more than 50%. Since the construction of
precompiled headers doesn't overly tax the compilation process they are
created at the beginning of flc()'s compilation process, and they can safely
be removed again once flc() has been compiled. 

    To compile a header file simply call the compiler passing it the name of a
header file. E.g.,
        verb(
    g++ --std=c++14 someheader.hh
        )
    Classes' internal header files are good candidates for precompilation as
they are included by all of the classes' sources, and they always include their
own class's main header file.

    Flc()'s distribution contains a script tt(convert2hh) that can optionally
be used to convert the extensions of internal header files of existing
projects to tt(.hh), and to include tt(.hh) files rather than tt(.ih) files in
bf(C++) source files. This script converts all tt(#include "xxx.ih")
directives in bf(C++) source files in and below the current working directory
to tt(#include "xxx.hh") directives, and renames all files having tt(.ih)
extensions to files having tt(.hh) extensions. If these files are part of a
bf(git)(1) archive then the script can also use tt(git) to rename the files
having tt(.ih) extensions.

manpagesection(5. OPTIONS)

    includefile(../manual/intro/options)
