NOUSERMACRO(StreamInfo connect resume name)

includefile(../../release.yo)

htmlbodyopt(text)(#27408B)
htmlbodyopt(bgcolor)(#FFFAF0)
whenhtml(mailto(Frank B. Brokken: f.b.brokken@rug.nl))


COMMENT(manpage, section, releasedate, archive, short name)
manpage(StreamInfo)(3)(_CurYrs_)(flexc++__CurVers_-x.tar.gz)
                    (Flexc++ Standard Input Class)

def(si)(0)(tt(StreamInfo))
def(f)(0)(bf(flexc++)(1))
def(itb)(1)(it() bf(ARG1))
redef(tt)(1)(em(ARG1))

manpagename(StreamInfo)(Standard flexc++ input stream class)

manpagesynopsis()
    bf(StreamInfo) is defined by f() in the scanner base class.

manpagedescription()

    The class si() is a wrapper class for stream based I/O. It is used by the
scanner class generated by f() where it is defined in the scanner base class
header file and the generated source file of the scanner's tt(lex) function.

    The class si() offers several constructors and members together supporting
the f()'s standard input stream handling. A variant is offered by the class
tt(LineStreamInfo), only differing from si() in the way line numbers are
handled when the scanner switches to another stream. 

    Other requirements can easily be implemented by deriving a class from
si(), offering the additional facilities. 

    Input streams are associated with the scanner classes generated by f()
according to the following inheritance scheme:

    itemization(
    it() The class tt(Scanner). The scanner itself is defined in a class
tt(Scanner) (f() allows its users to specify a different name for the scanner
class, but tt(Scanner) is the generic name used in this man-page). The clas
tt(Scanner), once declared in tt(scanner.h), may be augmented by declaring
additional member functions that can be called from, e.g., the scanner class's
member function tt(lex), cf. the f() man-page for details.
    it() The class tt(ScannerBase). The class tt(Scanner) publicly inherits
from a class tt(ScannerBase), declaring support functions and data members, as
well as an enum defining the mini-scanners that were defined in the lexical
scanner's specification file. The tt(ScannerBase) class offers, e.g., the
members tt(match) and tt(leng), described in the f() man-page.
    it() The class template tt(ScannerTemplate). The class tt(ScannerBase), in
turn, inherits publicly from a class template tt(ScannerTemplate). The class
template tt(ScannerTemplate) is initialized with a class like the predefined
classes tt(StreamInfo) or tt(LineStreamInfo) or with any other class designed
like tt(StreamInfo) (see below).
    it() The class tt(StreamBuffer). The class template tt(ScannerTemplate)
defines a nested class tt(StreamBuffer) and a (protected) object
tt(StreamBuffer d_curBuf). tt(StreamBuffer) forms a layer between the
tt(StreamInfo) kind of class used to initialize the class tt(ScannerTemplate)
with and tt(Scanner::lex) function. It buffers and manages 
characters received from tt(StreamInfo) and its members are for internal use
only. 
    )

    si))-like classes may be used instead of the predefined si() and
tt(LineStreamInfo) classes. The f() directives tt(streaminfoclassname) and 
tt(streaminfoinclude) can be used to inform the tt(ScannerTemplate) class of
the name and interface of such a class. E.g., using
    verb(
%option streaminfoclassname = "FStreamInfo"
%option streaminfoinclude = "../fstreaminfo/fstreaminfo.h"
    )

manpagesection(NAME SPACES)

    The classes tt(StreamInfo) and tt(LineStreamInfo) are defined in the
tt(StreamSwitching) name space. If the scanner class itself is defined in a
name space (e.g., tt(ScannerNS)) then tt(StreamInfo) and tt(LineStreamInfo)
are defined in that name space's sub name space (e.g.,
tt(ScannerNS::StreamSwitching).

manpagesection(INHERITS FROM)
    -

manpagesection(STREAMINFOTYPE)

    To facilitate access to the actual class type that was used to instantiate
a tt(ScannerTemplate) object the class template tt(ScannerTemplate) defines
the type tt(StreamInfoType) as a synonym of tt(ScannerTemplate)'s type
parameter. tt(Scanner) class object member functions may refer to
tt(StreamInfoType) to refer to the actually used si() class. Code outside of
the class tt(Scanner)'s scope may refer to tt(Scanner::StreamInfoType).

manpagesection(STREAMADAPTER)

The class template tt(ScannerTemplate) defines the tt(struct StreamAdapter)
offering two fields:
    itemization(
    it() tt(std::istream *in), a pointer to the currently used
tt(std::istream);
    it() tt(size_t lineno), counting the number of lines processed so far.
    )

manpagesection(CONSTRUCTORS)
    itemization(
    itb(StreamInfo()). The default constructor associates itself with
tt(std::cin). Replacement si() classes em(must) also provide a default
constructor.
    itb(StreamInfo(char const *name)). The si() object is associated with an
input stream named tt(name). The stream is opened, but no checks are performed
to verify that the stream has actually been opened. At destruction time the
opened stream is closed by the si() object.
    itb(StreamInfo(std::istream *in)). The si() object is associated with an
existing input stream tt(in). The si()'s name is initialized to
tt(std::istream *). The stream pointed to by tt(in) must have been dynamically
allocated. The si() object takes ownership of the tt(std::istream) object and
will delete the allocated memory at destruction time, closing the stream.
    )
    The standard copy constructor is not available.

    The class tt(LineStreamInfo) offers similar constructors.

manpagesection(DESTRUCTOR)

    The classes si() and tt(LineStreamInfo) take ownership of the
tt(std::istream) objects whose addresses they receive. Their destructors
delete the allocated memory, thereby closing the open file. To promote
reusability it is strongly advised that replacement classes do the same.

manpagesection(MEMBER FUNCTIONS)
    The class si() has three member functions. Since this class is used to
instantiate the class template tt(ScannerTemplate) replacement si() classes
must also define these member functions. Replacement classes may do this by
inheriting from si(), only reimplementing the members requiring alternate
implementations.
    itemization(
    it() tt(void connect(ScannerTemplate<StreamInfo>::StreamAdapter *ptr))nl()
 When switching to a new si() object its tt(connect) member is
called. tt(Connect) receives a pointer to the tt(StreamAdapter) managed by the
tt(Scanner) object and should merely assign new values to its tt(in) and
tt(lineno) members. No allocation or saving of existing values is
required. As si() has a member tt(std::istream *d_in) pointing to the stream
it owns, tt(connect) may simply assign tt(d_in) to tt(ptr->in) to ensure that
future reads performed by the scanner object use si()'s tt(d_in) stream. If,
following the stream switch, line counting should start at 1 tt(ptr->lineno)
should be set to 1 as well. In line with this, tt(connect) is implemented as
follows:
        verb(
void StreamInfo::connect(
                ScannerTemplate<StreamInfo>::StreamAdapter *ptr)
{
    ptr->in = d_in;
    ptr->lineno = 1;
}
        )
    it() tt(void resume(StreamInfo const &streamInfo, size_t lineno))nl()
 Once a file has been processed the scanner will automatically revert to the
stream it was previously reading restoring its line number. The line number
setting just before reverting to the previous stream is passed to tt(resume)
in its tt(lineno) parameter, and so when the intent is to revert back to the
original file's line number no further action is required. 

The predefined class tt(LineStreamInfo), however, continues counting lines. As
its tt(connect) member has saved the pointer to the tt(StreamAdapter) used by
the scanner in a data member tt(ScannerTemplate<StreamInfo>::StreamAdapter
*ptr) it can simply assign the tt(lineno) value to tt(d_ptr->lineno) to
accomplish line counting continuation. Here is its implementation:
        verb(
void LineStreamInfo::resume(
                LineStreamInfo const &streamInfo, size_t lineno)
{
    d_ptr->lineno = lineno;
}
        )
    it() tt(std::string const &name() const)nl()
 The name of the currently used stream is returned.
    )

manpagesection(EXAMPLE)

    To perform stream switching reinitializing the line counting the lexical
scanner merely needs to recognize an include-directive. Here is an example:
    
        verb(
%x include
%%
"#include "      begin(include);
[^#\n]*          {
                     std::cout << streamInfo().name() << ":" << 
                              lineno() << ": " << d_match << '\n';
                 }
\n 

<include>[^ \n]* {
                     std::cout << "Including " << d_match << ".\n";
                     begin(INITIAL);
                     pushStreamInfo(
                        new StreamInfoType(d_match.c_str())
                     );
                 }
    )

    Here is a class acting like si() but testing the readability of its
tt(istream) objects, throwing an exception if the stream cannot be
opened. Furthermore, the class offers a safeguard against recursive inclusion
by setting a limit to the maximum number of files that can be processed by the
scanner at the same time. 

    Caveat: to use an si() replacement class two directives must be specified
in the lexical scanner specification file. E.g.,
    verb(
%option streaminfoclassname = "FStreamInfo"
%option streaminfoinclude = "../fstreaminfo/fstreaminfo.h"
    )
    Although this prepares tt(scannerbase.h) for the use of tt(FStreamInfo),
tt(FstreamInfo) itself needs to know about tt(StreamSwitching::StreamInfo) as
it is derived from that class. So it must include tt(scannerbase.h). The
tt(FstreamInfo) declaration required by tt(scannerbase.h) can simply be
provided by a forward declaration of tt(FStreamInfo) in tt(fstreaminfo.h)'s
class header file:
        verb(
#include <iostream>
#include <stdexcept>

class FStreamInfo;

#include "../scanner/scannerbase.h"

class FStreamInfo: public StreamSwitching::StreamInfo
{
    static size_t s_inclusionDepth;

    public:
        FStreamInfo() = default;
        FStreamInfo(std::string const &name);
        FStreamInfo(std::string const &nameExpansion, 
                    std::string const &name);

        void resume(FStreamInfo const &streamInfo, size_t lineno);
        void connect(ScannerTemplate<FStreamInfo>::StreamAdapter *ptr);

    private:
        void checkStream() const;
};

FStreamInfo::FStreamInfo(std::string const &name)
:
    StreamInfo(name.c_str())
{
    checkStream();
}
FStreamInfo::FStreamInfo(string const &nameExpansion, string const &name)
:
    StreamInfo(new istringstream(nameExpansion))
{
    d_name = name;
    checkStream();
}
void FStreamInfo::resume(FStreamInfo const &streamInfo, size_t lineno)
{
    --s_inclusionDepth;
}
void FStreamInfo::checkStream() const
{
    if (!*d_in)
    {
        std::cerr << "cannot read `" << d_name << "'\n";
        throw std::runtime_error("#include: file not readable");
    }
}

size_t FStreamInfo::s_inclusionDepth = 0;

void FStreamInfo::connect(
        ScannerTemplate<FStreamInfo>::StreamAdapter *ptr)
{
    if (++s_inclusionDepth == 10)
    {
        std::cerr << "max. file inclusion depth exceeded for `" << 
                     d_name << "'\n";
        throw std::runtime_error("max. file inclusion depth exceeded");
    }
    ptr->in = d_in;
    ptr->lineno = 1;
}
        )
    To use the above class it can be specified by the scanner's constructor:
        verb(
Scanner::Scanner(string const &fname)
:
    ScannerBase(new StreamInfoType(fname))
{}
        )
    To allow tt(FStreamInfo) access to, e.g., tt(Scanner)'s tt(lineno)
function is somewhat complicated. Realizing that these functions are part of
tt(ScannerBase)'s interface and not of tt(Scanner)'s interface offers some
leeway to prevent circular dependencies. Here is the approach:
    itemization(
    it() provide tt(FStreamInfo)'s constructor with a tt(ScannerBase *)
        parameter;
    it() pass tt(this) to tt(FstreamInfo)'s constructor in tt(Scanner)'s
constructor.
    )
    Example:
        verb(
Scanner::Scanner(string const &fname)
:
    ScannerBase(new StreamInfoType(fname, this))
{}
        )
        
manpagefiles()

    em(scanner.h) - generic name of the scanner's base class, declaring
tt(class Scanner) nl()
    em(scannerbase.h) - generic name of the scanner's base class, declaring
tt(class ScannerBase), tt(ScannerTemplate), tt(StreamInfo) and
tt(LineStreamInfo) nl()
    em(lex.cc) - generic name of the scanner's tt(lex) function, implementing
some members of the classes declared in tt(scanner.h) and tt(scannerbase.h).

manpageseealso()
    f()

manpagebugs()
    None Reported.

manpageauthor()

Richard Berendsen (richardberendsen@xs4all.nl),nl()
Frank B. Brokken (f.b.brokken@rug.nl),nl()
Jean-Paul van Oosten (jpoosten@ai.rug.nl)




