includefile(include/header)

COMMENT(manpage, section, releasedate, archive, short name)
manpage(scannerbase.h)(3flexc++)(_CurYrs_)(flexc++__CurVers_-x.tar.gz)
                    (Scanner base class interface)

manpagename(scannerbase.h)
            (Base class of the Scanner class generated by flexc++)

manpagesynopsis()
    bf(#include "scannerbase.h")nl()

manpagedescription()

    By default, flc() generates a file tt(scannerbase.h) containing the
interface of the base class of the scanner class also generated by flc().  The
name of the file that is generated can easily be changed using flc()'s
tt(--baseclass-header) option. In this man-page we use the default name.

    The file tt(scanner.h) is generated at each new flc() run. It contains no
user-serviceable or extensible parts. Rewriting can be prevented by specifying
flc()'s tt(--no-baseclass-header) option).

manpagesection(PUBLIC ENUMS AND -TYPES)

    itemization(
    itb(enum class StartCondition__)
        This strongly typed enumeration defines the names of the start
conditions (i.e., mini scanners). It at least contains tt(INITIAL), but when
the tt(%s) or tt(%x) directives were used it also contains the identifiers of
the mini scanners declared by these directives. Since tt(StartCondition__) is
a strongly typed enum its values must be preceded by its enum name. E.g.,
        verb(
    begin(StartCondition__::INITIAL);
        )
    )

manpagesection(PROTECTED ENUMS AND -TYPES)

    itemization(
    itb(enum class ActionType__)
        This strongly typed enumeration is for internal use only.
    )

manpagesection(NO PUBLIC CONSTRUCTORS)

    There are no public constructors. tt(ScannerBase) is a base class for the
tt(Scanner) class generated by flc(). tt(ScannerBase) only offers 
protected constructors.

manpagesection(PUBLIC MEMBER FUNCTIONS)

    itemization(
    itb(bool debug() const)
       returns tt(true) if tt(--debug) or tt(%debug) was specified, otherwise
        tt(false).
    itb(std::string const  &filename()  const)
       returns the name of the file currently processed by the scanner object.
    itb(size_t              length()    const)
       returns the length of the text that was matched by tt(lex). With
        bf(flex++) this function was called tt(leng).
    itb(size_t              lineNr()    const)
       returns the line number of the currently scanned line. This function is
        always available (note: bf(flex++) only offered a similar function
        (called tt(lineno)) after using the tt(%lineno) option).
    itb(std::string const  &matched()   const)
       returns the text matched by tt(lex) (note: bf(flex++) offers a similar
        member called tt(YYText)).
    itb(void setDebug(bool onOff))
       Switches on/off  debugging output by providing the argument tt(true)
        or tt(false). Switching on debugging output only has visible effects
        if the tt(debug) option was specified.
    itb(void switchStreams(std::istream &in,
                                      std::ostream &out = std::cout))
       The currently processed input and output streams are closed, and
        processing continues at tt(in), writing output to tt(out). This is
        em(not) a stack-operation: after processing tt(in) processing
        does not return to the original stream.

        When flc() generates an interactive scanner, this member is 
        available (as a protected member). However, it should be considered an
        internal use only member.

    itb(void switchStreams(std::string const &infilename))
       The currently processed input stream is closed, and processing
        continues at the stream whose name is specified as the function's
        argument. This is em(not) a stack-operation: after processing
        tt(infilename) processing does not return to the original stream.

        bf(This member is not available with interactive scanners.)

    itb(void switchStreams(std::string const &infilename,
                                      std::string const &outfilename))
       The currently processed input and output streams are closed, and
        processing continues at the stream whose name is specified as the
        function's first argument, writing output to the file whose name is
        specified as the function's second argument. This latter file is
        rewritten. This is em(not) a stack-operation: after processing
        tt(infilename) processing does not return to the original stream.

        bf(This member is not available with interactive scanners.)
    )

manpagesection(PROTECTED CONSTRUCTORS)

    itemization(
    itb(ScannerBase(std::istream &in, std::ostream &out))
       The scanner object reads tt(in) and writes tt(out). It is called from
        the corresponnding tt(Scanner) constructor.
    itb(ScannerBase(std::string const &infilename, 
                                std::string const &outfilename))
       The scanner object opens and reads tt(infilename) and opens (rewrites)
        and writes tt(outfilename). It is called from the corresponding
        tt(Scanner) constructor.
    )

manpagesection(PROTECTED MEMBER FUNCTIONS)

    All member functions ending in two underscore characters are for internal
        use only and should not be called by user-defined members of the
        tt(Scanner) class. 

    The following members, however, 
        can safely be called by members of the generated tt(Scanner) class:

    itemization(
    itb(StartCondition__  startCondition() const)
       returns the currently active start condition (mini scanner);
    itb(bool popStream())
       closes the currently processed input stream and continues to process
        the most recently stacked input stream (removing it from the stack of
        streams). If this switch was successfully performed tt(true) is
        returned, otherwise (e.g., when the stream stack is empty) tt(false)
        is returned;
    itb(std::ostream &out())
       returns a reference to the scanner's output stream;
    itb(void begin(StartCondition__ startCondition))
       activate the regular expression rules associated with
        tt(StartCondition__ startCondition). As this enumeration is a strongly
        typed enum the tt(StartCondition__) scope must be specified as
        well. E.g., 
            verb(
        begin(StartCondition__::INITIAL);
            )
    itb(void echo() const) 
       The currently matched text (i.e., the text returned by the member
        tt(matched)) is inserted into the scanner object's output stream;
    itb(void accept(size_t nChars = 0))
       tt(accept(n)) returns all but the first `nChars' characters of the
        current token back to the input stream, where they will be rescanned
        when the scanner looks for the next match.  So, it matches `nChars' of
        the characters in the input buffer, rescanning the rest. This function
        effectively sets tt(length)'s return value to tt(nChars) (note: with
        bf(flex++) this function was called tt(less));
    itb(void redo(size_t nChars = 0))
       this member acts like tt(accept) but its argument counts backward from
        the end of the matched text. All but these tt(nChars) characters are
        kept and the last tt(nChar) characters are rescanned. This function
        effectively reduces tt(length)'s return value by tt(nChars);
    itb(void more())
       the matched text is kept and will be prefixed to the text that is
        matched at the next lexical scan;
    itb(void push(size_t ch))
       character tt(ch) is pushed back onto the input stream. I.e., it will be
        the character that is retrieved at the next attempt to obtain a
        character from the input stream;
    itb(void push(std::string const &txt))
       the characters in the string tt(txt) are pushed back onto the input
        stream. I.e., they will be the characters that are retrieved at the
        next attempt to obtain characters from the input stream. The
        characters in tt(txt) are retrieved from the first character to the
        last. So if tt(txt == "hello") then the tt('h') will be the character
        that's retrieved next, followed by tt('e'), etc, until tt('o');
    itb(void pushStream(std::istream &curStream))
        this function pushes tt(curStream) on the stream stack;
        bf(This member is not available with interactive scanners.)
    itb(void pushStream(std::string const &curName))
       same, but the stream tt(curName) is opened first, and the resulting
        tt(istream) is pushed on the stream stack;
        bf(This member is not available with interactive scanners.)
    itb(void setFilename(std::string const &name))
       this function sets the name of the stream returned by tt(filename) to
        tt(name);
    itb(void setMatched(std::string const &text))
       this function stores tt(text) in the matched text buffer. Following a
        call to this function tt(matched) returns tt(text).
    )

manpagesection(PROTECTED DATA MEMBERS)

    All protected data members are for internal use only, allowing tt(lex__)
to access them. All of them end in two underscore characters.

manpagesection(FLEX++ TO FLEXC++ MEMBERS)
    
setmanalign(lcl)
table(3)(lcl)(
    rowline()   
    row(cell(Flex++ (old))  cell()  cell(Flexc++ (new)))
    rowline()   
    row(cell(tt(lineno()))    cell()  cell(tt(lineNr())))
    row(cell(tt(YYText()))    cell()  cell(tt(matched())))
    row(cell(tt(less()))      cell()  cell(tt(accept())))
    rowline()   
)
manpagesection(EXAMPLE)

        verb(
class ScannerBase
{
            // idx: rule, value: tail length (NO_INCREMENTS if no tail)
    typedef std::vector<int> VectorInt;

    enum    // RuleFlagsCount Indices, see s_rfc__[]
    {
        RULE = 0,
        FLAGS,
        ACCCOUNT,
    };

    enum
    {
        FINAL = 1,
        INCREMENT = 2,
        COUNT = 4,
        BOL = 8
    };

    enum 
    {
        AT_EOF = -1
    };

protected:
    enum class ActionType__
    {
        CONTINUE,           // transition succeeded, go on
        ECHO_CH,            // echo ch itself (d_matched empty)
        ECHO_FIRST,         // echo d_matched[0], push back the rest
        MATCH,              // matched a rule
        RETURN,             // no further continuation, lex returns 0.
    };

public:
    enum class StartCondition__ {
        // $insert startCondNames
        INITIAL,
        vbar,
        str,
        pattern,
        mblock,
        quote,
        comment,
        charclass,
        patterntxt,
        option
    };

private:
    struct FinData        // Info about intermediate matched rules while
    {                     // traversing the DFA
        size_t rule;
        size_t matchLen;
        size_t tailCount;
    };

    struct Final
    {
        FinData atBOL;
        FinData notAtBOL;
    };

        // class Input encapsulates all input operations. 
        // Its member get() returns the next input character
// $insert inputInterface
    class Input
    {
        std::deque<unsigned char> d_deque;  // pending input chars
        std::istream *d_in;             // ptr for easy streamswitching
        size_t d_lineNr;                // line count

        public:
            Input();                    // iStream: dynamically allocated
            Input(std::istream *iStream);   
            size_t get();               // the next range
            void reRead(size_t ch);     // push back 'ch' (if <= 0x100)
                                        // push back str from idx 'fmIdx'
            void reRead(std::string const &str, size_t fmIdx);
            size_t lineNr() const
            {
                return d_lineNr;
            }
            void close()                // force closing the stream
            {
                delete d_in;
            }

        private:
            size_t next();              // obtain the next character
    };

    struct StreamStruct
    {
        std::string pushedName;
        Input pushedInput;
    };

    std::stack<StreamStruct>    d_streamStack;

    std::string     d_filename;       // name of the currently processed
    static size_t   s_istreamNr;      // file. With istreams it receives
                                      // the name "<istream #>", where
                                      // # is the sequence number of the 
                                      // istream (starting at 1)
    StartCondition__  d_startCondition;
    size_t          d_state;
    int             d_nextState;
    std::shared_ptr<std::ostream> d_out;
    bool            d_sawEOF;           // saw EOF: ignore tailCount
    bool            d_atBOL;            // the matched text starts at BOL
    std::vector<size_t> d_tailCount;     
    Final d_final;                      // 1st for BOL rules
    Input           d_input;
    std::string     d_matched;          // matched characters
    bool            d_return;           // return after a rule's action 
    bool            d_more;             // set to true by more()

protected:
    int     const (*d_dfaBase__)[79];

    static int     const s_dfa__[][79];
    static int     const (*s_dfaBase__[])[79];
    enum bool { s_interactive__ = false};
    enum size_t {
        s_rangeOfEOF__ = 76,
        s_finacIdx__   = 77,
        s_nRules__     = 71
    };
    static size_t  const s_ranges__[];
    static size_t  const s_rfc__[][3];
                                            // TODO: make configurable
    enum size_t { s_maxSizeofStreamStack__ = 10 }; 

public:
    ScannerBase(ScannerBase const &other)             = delete;
    ScannerBase &operator=(ScannerBase const &rhs)    = delete;

    bool                debug()     const;
    std::string const  &filename()  const;
    std::string const  &matched()   const;

    size_t              length()    const;
    size_t              lineNr()    const;

    void                setDebug(bool onOff);
    void                switchStreams(std::string const &infilename);
    void                switchStreams(std::string const &infilename,
                                      std::string const &outfilename);
protected:
    ScannerBase(std::istream &in, std::ostream &out);
    ScannerBase(std::string const &infilename, 
                std::string const &outfilename);

    StartCondition__  startCondition() const; // current start condition
    bool            popStream();
    std::ostream   &out();
    void            begin(StartCondition__ startCondition);
    void            echo() const;

//    `accept(n)' returns all but the first `n' characters of the current
// token back to the input stream, where they will be rescanned when the
// scanner looks for the next match.
//  So, it matches n of the characters in the input buffer, and so it 
//  accepts n characters, rescanning the rest. 
    void            accept(size_t nChars = 0);   // flex++: less
    void            redo(size_t nChars = 0);     // rescan the last nChar
                                                 // characters, reducing
                                                 // length() by nChars
    void            more();
    void            push(size_t ch);             // push char to Input
    void            push(std::string const &txt);// same: chars

    void            pushStream(std::istream &curStream);
    void            pushStream(std::string const &curName);
    void            setFilename(std::string const &name);
    void            setMatched(std::string const &text);

    static std::string istreamName__();
        
        // members used by lex__(): they end in __ and should not be used
        // otherwise.

    ActionType__    actionType__(size_t range); // next action
    bool            return__();             // 'return' from codeblock
    size_t          matched__(size_t ch);   // handles a matched rule
    size_t          getRange__(int ch);     // convert char to range
    size_t          get__();                // next character
    size_t          state__() const;        // current state 
    void            continue__(int ch);     // handles a transition
    void            echoCh__(size_t ch);    // echoes ch, sets d_atBOL
    void            echoFirst__(size_t ch); // handles unknown input
    void            inspectRFCs__();        // update d_tailCount
    void            noReturn__();           // d_return to false
    void            pushFront__(size_t ch); // return char to Input
    void            reset__();              // prepare for new cycle

private:
    void pushStream(std::string const &name, std::istream *streamPtr);
    void determineMatchedSize(FinData const &final);
    bool atFinalState();
};
        )

manpageseealso()

    bf(flexc++)(1), 
    bf(input)(3flexc++),  bf(rules)(3flexc++),  bf(scanner.h)(3flexc++),  
    bf(scannerbase.h)(3flexc++), 

manpagebugs()
    None Reported.

includefile(include/trailer)
