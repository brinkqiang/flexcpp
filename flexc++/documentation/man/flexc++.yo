NOUSERMACRO(lex setDebug)

includefile(../../release.yo)

htmlbodyopt(text)(#27408B)
htmlbodyopt(bgcolor)(#FFFAF0)
whenhtml(mailto(Frank B. Brokken: f.b.brokken@rug.nl))

DEFINEMACRO(lsoption)(3)(\
    bf(--ARG1)=tt(ARG3) (bf(-ARG2))\
)
DEFINEMACRO(laoption)(2)(\
    bf(--ARG1)=tt(ARG2)\
)
DEFINEMACRO(loption)(1)(\
    bf(--ARG1)\
)
DEFINEMACRO(soption)(1)(\
    bf(-ARG1)\
)

DEFINEMACRO(flc)(0)(bf(flexc++))
DEFINEMACRO(Flc)(0)(bf(Flexc++))
DEFINEMACRO(Cpp)(0)(bf(C++))
DEFINEMACRO(prot)(0)(tt((prot)))

DELETEMACRO(tt)
DEFINEMACRO(tt)(1)(em(ARG1))

COMMENT( man-request, section, date, distribution file, general name)
manpage(flexc++)(1)(_CurYrs_)(flexc++._CurVers_.tar.gz)
        (flexc++ scanner generator)

COMMENT( man-request, larger title )
manpagename(flexc++)(Generate a C++ scanner class and parsing function)

COMMENT( all other: add after () )
manpagesynopsis()
       flc() [OPTIONS] tt(rules-file)

manpagedescription()

    Flc()(1) was designed after bf(flex)(1) and bf(flex++)(1). Like
these latter two programs flc() generates code that performs
pattern-matching on text, possibly executing actions when certain em(regular
expressions) are recognized.

    Flc(),  contrary to bf(flex) and
bf(flex++), generates code that is explicitly intended for use by bf(C++)
programs. The well-known bf(flex)(1) program generates bf(C) source-code and
bf(flex++)(1) merely offers a bf(C++)-like shell around the tt(yylex) function
generated by bf(flex)(1) and hardly supports present-day ideas about
bf(C++) software development.

    Contrary to this, flc() creates a well-defined bf(C++) class
offering a predefined member function bf(lex) matching input against regular
expressions and possibly executing bf(C++) code that can be associated with
matched  regular expressions. The code generated by bf(flexc++) is pure
bf(C++), allowing its users to apply all the featured offered by that
language. 

    manpagesection(GENERATED FILES)

Flc() generates three files from a well-formed input file:
    itemization(
    it() A file containing the implementation of the tt(lex) member function
and its support functions. By default this file is named tt(lex.cc).
    it() A file containing the scanner's class interface. By default this file
is named tt(scanner.h). The scanner class itself is generated once and is
thereafter `owned' by the programmer, who may change it em(ad-lib). Newly
added members (data members, function members) will survive future flc() runs
as flc() will never rewrite an existing scanner class interface file, unless
explicitly ordered to do so. (see also bf(scanner)(3flexc++)).
    it() A file containing the interface of the scanner class's em(base
class). The scanner class is publicly derived from this base class. It is used
to minimize the size of the scanner interface itself. The scanner base class
is `owned' by bf(flexc++) and should never be hand-modified. By
default the scanner's base class is provided in the file
tt(scannerbase.h). At each new flc() run this file is rewritten unless flc()
is explicitly ordered em(not) to do so (see also bf(scannerbase)(3flexc++)).
    it() A file containing the em(implementation header). This file should
contain includes and declarations that are only required when compiling the
members of the scanner class. By default this file is named
tt(scanner.ih). This file, like the file containing the scanner class's
interface is never rewritten by flc() unless flc() is explicitly ordered to do
so (see also bf(implementationheader)(3flexc++)). 
    )

manpageoptions()

    If available, single letter options are listed between parentheses
following their associated long-option variants. Single letter options require
arguments if their associated long options require arguments as well.
    itemization(
    it() lsoption(baseclass-header)(b)(header)nl()
           Use tt(header) as the pathname of the file containing the scanner
           class's base class. Defaults to the name of the scanner class plus
           tt(base.h)
    it() lsoption(baseclass-skeleton)(C)(skeleton)nl() 
           Use tt(skeleton) as the pathname of the file containing the
            skeleton of the scanner class's base class. Its filename defaults
            to tt(flexc++base.h).
    it() lsoption(class-header)(c)(header)nl()
           Use tt(header) as the pathname of the file containing the scanner
            class. Defaults to the name of the scanner class plus the suffix
            tt(.h)
    it() laoption(class-name)(class)nl()
           Use tt(class) (rather than tt(Scanner)) as the name of the scanner
            class. Unless overridden by other options generated files will be
            given the (transformed to lower case) tt(class*) name instead of
            tt(scanner)*.
    it() lsoption(class-skeleton)(C)(skeleton)nl()
           Use tt(skeleton) as the pathname of the file containing the
            skeleton of the scanner class. Its filename defaults to
            tt(flexc++.h). 
    it() lloption(construction)(K)nl() 
           To do
    it() loption(debug) (soption(d))nl() 
           Provide tt(lex) and its support functions with debugging code,
            showing the actual parsing process on the standard output
            stream. When included, the debugging output is active by default,
            but its activity may be controlled using the tt(setDebug(bool
            on-off)) member. Note that no tt(#ifdef DEBUG) macros are used
            anymore. By rerunning flc() without the bf(--debug) option an
            equivalent scanner is generated not containing the debugging
            code. 
    it() loption(debug-steps) (soption(s))nl() 
           To do
    it() loption(force-class-header)nl()
           By default the generated class header is not overwritten once it
            has been created. This option can be used to force the
            (re)writing of the file containing the scanner's class.
    it() loption(force-implementation-header)nl()
           By default the generated implementation header is not overwritten
            once it has been created. This option can be used to force the
            (re)writing of the implementation header file.
    it() loption(help) (soption(h))nl()
            Write basic usage information to the standard output stream and
            terminate. 
    it() lsoption(implementation-header)(i)(header)nl()
           Use tt(header) as the pathname of the file containing the
            implementation header. Defaults to the name of the generated
            scanner class plus the suffix tt(.ih). The implementation header
            should contain all directives and declarations em(only) used by
            the implementations of the scanner's member functions. It is the
            only header file that is included by the source file containing
            bf(lex())'s implementation . User defined implementation of
            other class members may use the same convention, thus
            concentrating all directives and declarations that are required
            for the compilation of other source files belonging to the scanner
            class in one header file.
    it() lsoption(implementation-skeleton)(I)(skeleton)nl()
           Use tt(skeleton) as the pathname of the file containing the
            skeleton of the implementation header. Its filename defaults to
            tt(flexc++.ih).
    it() lsoption(lex-skeleton)(L)(skeleton)nl()
           Use tt(skeleton) as the pathname of the file containing the
            tt(lex()) member function's skeleton. Its filename defaults to
            tt(flexc++.cc).
    it() lsoption(lex-function-name)(funname)nl()
           Use tt(funname) rather than tt(lex) as the name of the member
            function performing the lexical scanning.
    it() lsoption(lex-source)(l)(source)nl()
           Define tt(source) as the name of the source file containing the
            scanner member function tt(lex). Defaults to tt(lex.cc).
    it() loption(lines) nl() 
           Put tt(#line) preprocessor directives in the file containing the
            scanner's tt(lex) function. By including this option the
            compiler and debuggers will associate errors with lines in your
            grammar specification file, rather than with the source file
            containing the tt(lex) function itself.
    it() lsoption(namespace)(n)(namespace)nl()
           Define the scanner base class, the paser class and the scanner
            implentations in the namespace tt(namespace). By default
            no namespace is defined. If this options is used the
            implementation header will contain a commented out tt(using
            namespace) declaration for the requested namespace. 
    it() loption(no-baseclass-header)nl()
           Do not write the file containing the scanner's base class interface
            even if it doesn't yet exist. By default the file containing the
            scanner's base class interface is (re)written each time flc() is
            called.
    it() loption(no-lines)nl() 
           Do not put bf(#line) preprocessor directives in the file containing
            the scanner's tt(lex) function. This option is primarily useful
            in combination with the bf(%lines) directive, to suppress that
            directive. It also overrides option bf(--lines), though.
    it() loption(no-lex-source)nl()
           Do not write the file containing the scanner's predefined scanner
            member functions, even if that file doesn't yet exist. By default
            the file containing the scanner's tt(lex) member function is
            (re)written each time flc() is called. This option
            should normally be avoided, as this file contains parsing
            tables which are altered whenever the grammar definition is
            modified. 
    it() loption(print-tokens) (soption(t))nl() 
           To do
    it() loption(show-filenames) (soption(F))nl() 
           Write the names of the files that are generated to the 
            standard error stream.
    it() lsoption(skeleton-directory)(S)(directory)nl() 
           Specifies the directory containing the skeleton files to use. This
            option can be overridden by the specific skeleton-specifying
            options (tt(-B -C, -H,) and tt(-I)).
    it() loption(usage) (option(h))nl()
            Write basic usage information to the standard output stream and
            terminate. 
    it() loption(verbose)(soption(V))nl() 
           To do
     it() loption(version) (soption(v))nl()
            Display flc()'s version number and terminate.
    )

manpagesection(DIRECTIVES)


manpagesection(PUBLIC MEMBERS AND -TYPES)

    To complete

    The following public members can be used by users of the scanner classes
generated by flc() (tt(`Scanner Class'::) prefixes are silently implied):
    itemization(
    it() bf(int lex()):nl()
           The scanner's parsing member function. It returns 0 when parsing has
            completed successfully, 1 if errors were encountered while parsing
            the input.
    it() bf(void setDebug(bool mode)):nl()
       This member can be used to activate or deactivate the debug-code
        compiled into the parsing function. It is always available but is only
        operational if the tt(%debug) directive or tt(--debug) option was
        specified.When debugging code has been compiled into the parsing
        function, it is em(not) active by default. To activate the debugging
        code, use bf(setDebug(true)).
       This member can be used to activate or deactivate the debug-code
        compiled into the parsing function. It is available but has no
        effect if no debug code has been compiled into the parsing
        function. When debugging code has been compiled into the parsing
        function, it is active by default, but debug-code is suppressed by
        calling bf(setDebug(false)).
    )
    
manpagesection(PROTECTED ENUMS AND -TYPES)

    To do


manpagesection(PRIVATE MEMBER FUNCTIONS)

    To do

manpagesection(PROTECTED DATA MEMBERS)

    To do

manpagesection(TYPES AND VARIABLES IN THE ANONYMOUS NAMESPACE)

    To do

manpagesection(OBSOLETE SYMBOLS)

    All bf(DECLARATIONS) and bf(DEFINE) symbols not listed above but defined
in bf(flex++) are obsolete with flc(). In particular, there is no bf(%header{
... %}) section anymore. Also, all bf(DEFINE) symbols related to member
functions are now obsolete. There is no need for these symbols anymore as they
can simply be declared in the class header file and defined elsewhere.
                    
manpagesection(EXAMPLE)

    See the bf(rules)(3flexc++) man-page


manpagefiles()

    Flc()'s default skeleton files are in tt(/usr/share/flexc++).nl()
    Flc() by default generates the following files:
        itemization(
        itt(scanner.h): the header file containing the scanner class's
            interface. 
        itt(scannerbase.h): the header file containing the interface of the 
            scanner class's base class.
        itt(scanner.ih): the internal header file that is meant to be included
            by the scanner class's source files (e.g., it is included by
            tt(lex.cc), see the next file), and that should contain all
            declarations required for compiling the scanner class's sources.
        itt(lex.cc): the source file implementing the scanner class member
            function tt(lex) (and support functions), performing the lexical
            scan.

manpageseealso()

    bf(input)(3flexc++),  bf(rules)(3flexc++),  bf(scanner)(3flexc++),  
    bf(scannerbase)(3flexc++), 

manpagebugs()

    To do

manpagesection(ABOUT flexc++)

    To do
    
manpageauthor()
