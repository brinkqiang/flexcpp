NOUSERMACRO(lex setDebug)

includefile(../../../release.yo)

htmlbodyopt(text)(#27408B)
htmlbodyopt(bgcolor)(#FFFAF0)
whenhtml(mailto(Frank B. Brokken: f.b.brokken@rug.nl))

DEFINEMACRO(lsoption)(3)(\
    bf(--ARG1)=tt(ARG3) (bf(-ARG2))\
)
DEFINEMACRO(laoption)(2)(\
    bf(--ARG1)=tt(ARG2)\
)
DEFINEMACRO(loption)(1)(\
    bf(--ARG1)\
)
DEFINEMACRO(soption)(1)(\
    bf(-ARG1)\
)

DEFINEMACRO(flc)(0)(bf(flexc++))
DEFINEMACRO(Flc)(0)(bf(Flexc++))
DEFINEMACRO(Cpp)(0)(bf(C++))
DEFINEMACRO(prot)(0)(tt((prot)))

DELETEMACRO(tt)
DEFINEMACRO(tt)(1)(em(ARG1))
DEFINEMACRO(itt)(1)(it() tt(ARG1))

COMMENT( man-request, section, date, distribution file, general name)
manpage(flexc++)(1)(_CurYrs_)(flexc++._CurVers_.tar.gz)
        (flexc++ scanner generator)

COMMENT( man-request, larger title )
manpagename(flexc++)(Generate a C++ scanner class and parsing function)

COMMENT( all other: add after () )
manpagesynopsis()
       flc() [OPTIONS] tt(rules-file)

manpagedescription()

    Flc()(1) was designed after bf(flex)(1) and bf(flex++)(1). Like these
latter two programs flc() generates code performing pattern-matching on text,
possibly executing actions when certain em(regular expressions) are
recognized.

    Flc(), contrary to bf(flex) and bf(flex++), generates code that is
explicitly intended for use by bf(C++) programs. The well-known bf(flex)(1)
program generates bf(C) source-code and bf(flex++)(1) merely offers a
bf(C++)-like shell around the tt(yylex) function generated by bf(flex)(1) and
hardly supports present-day ideas about bf(C++) software development.

    Contrary to this, flc() creates a bf(C++) class offering a predefined
member function bf(lex) matching input against regular expressions and
possibly executing bf(C++) code once regular expressions were matched. The
code generated by bf(flexc++) is pure bf(C++), allowing its users to apply all
of the features offered by that language.

    manpagesection(QUICK START)

    A bare-bones, no-frills scanner is generated as follows:

    itemization(
    it() Create a file tt(lexer) defining the regular expressions to
recognize, and the tokens to return. Use token values exceeding 0xff if plain
ascii character values can also be used as token values. Example (assume
capitalized words are token-symbols defined in an enum defined by the scanner
class):
        verb(
%%
[ \t\n]+                            // skip white space chars.
[0-9]+                              return NUMBER;
[[:alpha:]_][[:alpha:][:digit:]_]*  return IDENTIFIER;
.                                   return matched()[0];
        )

    it() Execute:
        verb(
    flexc++ lexer
        )
    This generates four files):tt(scanner.h, scanner.ih, scannerbase.h), and
tt(lex.cc) 

    it() Edit tt(scanner.h), add the enum defining the token-symbols in
(usually) the public section of the class tt(Scanner). E.g.,
        verb(
class Scanner: public ScannerBase
{
    public:
        enum Tokens
        {
            IDENTIFIER = 0x100,
            NUMBER
        };
    // ... (etc, as generated by flexc++)
        )

    it() Create a file defining tt(int main), e.g.:
        verb(
#include <iostream>
#include "scanner.h"

using namespace std;

int main()
{
    Scanner scanner;        // define a Scanner object

    while (int token = scanner.lex())   // get all tokens
    {
        string const &text = scanner.matched();
        switch (token)
        {
            case IDENTIFIER:
                cout << "identifier: " << text << '\n';
            break;

            case NUMBER:
                cout << "number: " << text << '\n';
            break;

            default:
                cout << "char. token: `" << text << "'\n";
            break;
        }
    }
}
        )
    it() Compile all tt(.cc) files:
        verb(
    g++ --std=c++0x *.cc
        )
    
    it() To `tokenize' tt(main.cc), execute:
        verb(
    a.out < main.cc
        )
    )

    manpagesection(QUICK START: FLEXC++ and BISONC++)

To interface flc() to the bf(bisonc++)(1) parser generator proceed as follows:
    itemization(
    it() Specify a grammar that can be processed by bf(bisonc++)(1). Assuming
that the scanner and parser are developed in, respectively, the
sub-directories tt(scanner) and tt(parser), then a simple grammar
specification that can be used with the scanner developed in the previous
section is, e.g., write the file tt(parser/grammar):
        verb(
%scanner                ../scanner/scanner.h
%scanner-token-function d_scanner.lex()

%token IDENTIFIER NUMBER CHAR

%%

startrule:
    startrule tokenshow
|
    tokenshow
;

tokenshow:
    token
    {
        std::cout << "matched: " << d_scanner.matched() << '\n';
    }
;

token:
    IDENTIFIER
|
    NUMBER
|
    CHAR
;
    )
    it() Write a scanner specification file. E.g.,
    verb(
%%

[ \t\n]+                            // skip white space chars.
[0-9]+                              return Parser::NUMBER;
[[:alpha:]_][[:alpha:][:digit:]_]*  return Parser::IDENTIFIER;
.                                   return Parser::CHAR;
    )
    This causes the scanner to  return tt(Parser) tokens to the generated
parser. 

    it() Add the line
    verb(
#include "../parser/Parserbase.h"
    )
    to the file tt(scanner/scanner.ih)

    it() Write a simple tt(main) function in the file tt(main.cc). E.g.,
    verb(
#include "parser/Parser.h"

int main(int argc, char **argv)
{
    Parser parser;

    parser.parse();
}
    )
    
    it() Generate a scanner in the tt(scanner) subdirectory:
    verb(
flexc++ lexer
    )
    
    it() Generate a parser in the tt(parser) subdirectory:
    verb(
bisonc++ grammar
    )
    
    it() Compile all sources:
    verb(
g++ --std=c++0x *.cc */*.cc
    )

    it() Execute the program, providing it some source file to be processed:
    verb(
a.out < main.cc
    )
        )

    manpagesection(GENERATED FILES)

Flc() generates three files from a well-formed input file:
    itemization(
    it() A file containing the implementation of the tt(lex) member function
and its support functions. By default this file is named tt(lex.cc).
    it() A file containing the scanner's class interface. By default this file
is named tt(scanner.h). The scanner class itself is generated once and is
thereafter `owned' by the programmer, who may change it em(ad-lib). Newly
added members (data members, function members) will survive future flc() runs
as flc() will never rewrite an existing scanner class interface file, unless
explicitly ordered to do so. (see also bf(scanner)(3flexc++)).
    it() A file containing the interface of the scanner class's em(base
class). The scanner class is publicly derived from this base class. It is used
to minimize the size of the scanner interface itself. The scanner base class
is `owned' by bf(flexc++) and should never be hand-modified. By
default the scanner's base class is provided in the file
tt(scannerbase.h). At each new flc() run this file is rewritten unless flc()
is explicitly ordered em(not) to do so (see also bf(scannerbase)(3flexc++)).
    it() A file containing the em(implementation header). This file should
contain includes and declarations that are only required when compiling the
members of the scanner class. By default this file is named
tt(scanner.ih). This file, like the file containing the scanner class's
interface is never rewritten by flc() unless flc() is explicitly ordered to do
so (see also bf(implementationheader)(3flexc++)). 
    )

manpageoptions()

    If available, single letter options are listed between parentheses
following their associated long-option variants. Single letter options require
arguments if their associated long options require arguments as well.
    itemization(
    it() lsoption(baseclass-header)(b)(header)nl()
           Use tt(header) as the pathname of the file containing the scanner
           class's base class. Defaults to the name of the scanner class plus
           tt(base.h)
    it() lsoption(baseclass-skeleton)(C)(skeleton)nl() 
           Use tt(skeleton) as the pathname of the file containing the
            skeleton of the scanner class's base class. Its filename defaults
            to tt(flexc++base.h).
    it() lsoption(class-header)(c)(header)nl()
           Use tt(header) as the pathname of the file containing the scanner
            class. Defaults to the name of the scanner class plus the suffix
            tt(.h)
    it() laoption(class-name)(class)nl()
           Use tt(class) (rather than tt(Scanner)) as the name of the scanner
            class. Unless overridden by other options generated files will be
            given the (transformed to lower case) tt(class*) name instead of
            tt(scanner)*.
    it() lsoption(class-skeleton)(C)(skeleton)nl()
           Use tt(skeleton) as the pathname of the file containing the
            skeleton of the scanner class. Its filename defaults to
            tt(flexc++.h). 
    it() lloption(construction)(K)nl() 
           To do
    it() loption(debug) (soption(d))nl() 
           Provide tt(lex) and its support functions with debugging code,
            showing the actual parsing process on the standard output
            stream. When included, the debugging output is active by default,
            but its activity may be controlled using the tt(setDebug(bool
            on-off)) member. Note that tt(#ifdef DEBUG) macros are not used
            anymore. By rerunning flc() without the bf(--debug) option an
            equivalent scanner is generated not containing the debugging
            code. 
    it() loption(force-class-header)nl()
           By default the generated class header is not overwritten once it
            has been created. This option can be used to force the
            (re)writing of the file containing the scanner's class.
    it() loption(force-implementation-header)nl()
           By default the generated implementation header is not overwritten
            once it has been created. This option can be used to force the
            (re)writing of the implementation header file.
    it() loption(help) (soption(h))nl()
            Write basic usage information to the standard output stream and
            terminate. 
    it() lsoption(implementation-header)(i)(header)nl()
           Use tt(header) as the pathname of the file containing the
            implementation header. Defaults to the name of the generated
            scanner class plus the suffix tt(.ih). The implementation header
            should contain all directives and declarations em(only) used by
            the implementations of the scanner's member functions. It is the
            only header file that is included by the source file containing
            bf(lex())'s implementation . User defined implementation of
            other class members may use the same convention, thus
            concentrating all directives and declarations that are required
            for the compilation of other source files belonging to the scanner
            class in one header file.
    it() lsoption(implementation-skeleton)(I)(skeleton)nl()
           Use tt(skeleton) as the pathname of the file containing the
            skeleton of the implementation header. Its filename defaults to
            tt(flexc++.ih).
    it() lsoption(lex-skeleton)(L)(skeleton)nl()
           Use tt(skeleton) as the pathname of the file containing the
            tt(lex()) member function's skeleton. Its filename defaults to
            tt(flexc++.cc).
    it() loption(interactive)nl()
           Generate an interactive scanner. An interactive scanner reads lines
            from the input stream, and then returns the tokens encountered on
            that line. The interactive scanner implemented by flc() only
            predefines the tt(Scanner(std::istream &in, std::ostream &out))
            constructor, by default assuming that input is read from
            tt(std::cin). See also the tt(INTERACTIVE SCANNER) section.
    it() laoption(lex-function-name)(funname)nl()
           Use tt(funname) rather than tt(lex) as the name of the member
            function performing the lexical scanning.
    it() lsoption(lex-source)(l)(source)nl()
           Define tt(source) as the name of the source file containing the
            scanner member function tt(lex). Defaults to tt(lex.cc).
    it() loption(lines) nl() 
           Put tt(#line) preprocessor directives in the file containing the
            scanner's tt(lex) function. By including this option the
            compiler and debuggers will associate errors with lines in your
            grammar specification file, rather than with the source file
            containing the tt(lex) function itself.
    it() lsoption(namespace)(n)(namespace)nl()
           Define the scanner base class, the paser class and the scanner
            implentations in the namespace tt(namespace). By default
            no namespace is defined. If this options is used the
            implementation header will contain a commented out tt(using
            namespace) declaration for the requested namespace. 
    it() loption(no-baseclass-header)nl()
           Do not write the file containing the scanner's base class interface
            even if it doesn't yet exist. By default the file containing the
            scanner's base class interface is (re)written each time flc() is
            called.
    it() loption(no-lines)nl() 
           Do not put bf(#line) preprocessor directives in the file containing
            the scanner's tt(lex) function. This option is primarily useful
            in combination with the bf(%lines) directive, to suppress that
            directive. It also overrides option bf(--lines), though.
    it() loption(no-lex-source)nl()
           Do not write the file containing the scanner's predefined scanner
            member functions, even if that file doesn't yet exist. By default
            the file containing the scanner's tt(lex) member function is
            (re)written each time flc() is called. This option
            should normally be avoided, as this file contains parsing
            tables which are altered whenever the grammar definition is
            modified. 
    it() loption(print-tokens) (soption(t))nl() 
           To do
    it() loption(show-filenames) (soption(F))nl() 
           Write the names of the files that are generated to the 
            standard error stream.
    it() lsoption(skeleton-directory)(S)(directory)nl() 
           Specifies the directory containing the skeleton files to use. This
            option can be overridden by the specific skeleton-specifying
            options (tt(-B -C, -H,) and tt(-I)).
    it() loption(usage) (option(h))nl()
            Write basic usage information to the standard output stream and
            terminate. 
    it() loption(verbose)(soption(V))nl() 
           The verbose option generates on the standard output stream an
            overview of the rules (plus their filenames and line numbers); of
            the character ranges used by the scanner; of the states of the
            NFA; of the states defining the DFA(s); and the generated DFA(s).
     it() loption(version) (soption(v))nl()
            Display flc()'s version number and terminate.
    )

manpagesection(INTERACTIVE SCANNERS)

An interactive scanner is characterized by the fact that scanning is postponed
until an end-of-line character has been received, followed by reading all
information on the line, read so far. Flc() supports the tt(--interactive)
option (or the equivalent tt(%interactive) directive), generating an
interactive scanner. Here it is assumed that 
tt(Scanner) is the name of the scanner class generated by flc().

The interactive scanner generated by flc() has the following characteristics:
    itemization(
    it() The tt(Scanner) class is derived privately from
        tt(std::istringstream) and (as usual) publicly from tt(ScannerBase).
    it() The tt(istringstream) base class is constructed by its default
        constructor. 
    it() The function tt(lex)'s default implementation is removed from
        tt(scanner.h) and is implemented in the generated tt(lex.cc) source
        file. It performs the following tasks:

        - If the token returned by the scanner is not equal to 0 it is
            returned as then next token;

        - Otherwise the next line is retrieved from the input stream
            passed to the tt(Scanner)'s constructor (by default tt(std::cin)).
            If this fails, 0 is returned.

        - A tt('\n') character is appended to the just read line, and the
            scanner's tt(std::istringstream) base class object is
            re-initialized with that line;

        - The member tt(lex__) returns the next token.
    )
    This implementation allows code calling tt(Scanner::lex()) to conclude, as
usual, that the input is exhausted when tt(lex) returns 0.

Here is an example of how such a scanner could be used:
    itemization(
        verb(
    // scanner generated with: 'flexc++ --interactive lexer' or with
    // 'flexc++ lexer' if lexer contains the %interactive directive
    int main()
    {
        Scanner scanner;        // by default: read from std::cin 
    
        while (true)
        {
            cout << "? ";       // prompt at each line

            while (true)        // process all the line's tokens
            {
                int token = scanner.lex();
    
                if (token == '\n')  // end of line: new prompt
                    break;
    
                if (token == 0)     // end of input: done
                    return 0;
    
                                    // process other tokens
                cout << scanner.matched() << '\n';
                if (scanner.matched()[0] == 'q')
                    return 0;
            }
        }
    }
        )
    )

manpagesection(EXAMPLE)

    See the bf(QUICKSTART) section in this man-page and the 
bf(rules)(3flexc++) man-page

manpagefiles()

    Flc()'s default skeleton files are in tt(/usr/share/flexc++).nl()
    By default, flc() generates the following files:
        itemization(
        itt(scanner.h): the header file containing the scanner class's
            interface. 
        itt(scannerbase.h): the header file containing the interface of the 
            scanner class's base class.
        itt(scanner.ih): the internal header file that is meant to be included
            by the scanner class's source files (e.g., it is included by
            tt(lex.cc), see the next file), and that should contain all
            declarations required for compiling the scanner class's sources.
        itt(lex.cc): the source file implementing the scanner class member
            function tt(lex) (and support functions), performing the lexical
            scan.
    )

manpageseealso()

    itemization(
    it() bf(input)(3flexc++): normally not needed. Describes how flc()'s
tt(ScannerBase) class communicates with the actual input device. Read this
man-page if you want to implement your own tt(Input) class.

    it() bf(rules)(3flexc++): describes how to write a flc() scanner
specification file. This file is frequently named tt(lexer).

    it() bf(scanner)(3flexc++): describes the interface of the scanner-class
generated by flc(). This is a very lean class, which is usually extended by
flc()'s user, who adds members to this class. This class derives from a
scanner-base class, whose public and protected members are described in the
next man-page:

    it() bf(scannerbase)(3flexc++): describes the members that are available
to the scanner class and to the users of scanners generated by flc().
    )

manpagebugs()

    None reported

manpagesection(ABOUT flexc++)

    Flc() was originally started as a programming project by Jean-Paul van
Oosten and Richard Berendsen in the 2007-2008 academic year. After graduating,
Richard left the project and moved to Amsterdam. Jean-Paul remained in
Groningen, and after on-and-off activities on the project, in close
cooperation with Frank B. Brokken, Frank undertook a rewrite of the project's
code around 2010. During the development of flc(), the lookahead-operator
handling continuously threatened the completion of the project. By now, the
project has evolved to a level that we feel it's defensible to publish the
program, although we still tend to consider the program in its experimental
stage; it will remain that way until we decide to move its version from the
0.9x.xx series to the 1.xx.xx series.

includefile(include/trailer.yo)
