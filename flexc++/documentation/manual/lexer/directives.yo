    Some directives require arguments, which are usually provided following
separating (but optional) tt(=) characters. Arguments of directives, are text,
surrounded by double quotes (strings). If a string must itself contain a
double quote or a backslash, then precede these characters by a backslash. The
exceptions are the tt(%s) and tt(%x) directives, which are immediately
followed by name lists, consisting of identifiers separated by blanks.  Here
is an example of the definition of a directive:
        verb(
    %class-name = "MyScanner"
        )

    The following directives are available:

    itemization(
    it() bf(%baseclass-header) tt(= "header") nl()
           Defines the pathname of the file containing the scanner class's
            base class interface. Corresponding command-line option:
            tt(--baseclass-header).
    it() bf(%class-header) tt(= "header") nl()
           Defines the pathname of the file containing the scanner class's
            interface. Corresponding command-line option:
            tt(--class-header).
    it() bf(%class-name) tt( = "class-name") nl()
           Declares the name of the scanner class generated by flc(). This
            directive corresponds to the tt(%name) directive used by
            bf(flex++)(1). Contrary to bf(flex++)'s tt(%name) declaration,
            tt(class-name) may appear anywhere in the first section of the
            grammar specification file. It may be defined only once. If no
            tt(class-name) is specified the default class name (tt(Scanner))
            is used. Corresponding command-line option:
            tt(--class-name).
    it() bf(%debug) nl() 
           Provide tt(lex) and its support functions with debugging code,
            showing the actual parsing process on the standard output
            stream. When included, the debugging output is active by default,
            but its activity may be controlled using the tt(setDebug(bool
            on-off)) member. Note that no tt(#ifdef DEBUG) macros are used in
            the generated code. 
COMMENT(
            The tt(%debug) option allows for a  fine-grained control over what
            debug information is provided. This is realized by appending tt(=
            debug-list) to tt(%debug), where tt(debug-list) is a
            comma-separated list of the following keywords:nl()

            table(2)(ll)(
            row(cell(tt(action))cell(show decisions made while matching rules,
                and the numbers of rules that were matched))
            )
END)    
            
    it() bf(%implementation-header) tt(= "header") nl()
           Defines the pathname of the file to contain the implementation
            header.  Corresponding command-line option:
            tt(--implementation-header).
    it() bf(%input-implementation) tt(= "sourcefile") nl()
           Defines the pathname of the file containing the implementation of a
            user-defined tt(Input) class. 
    it() bf(%input-interface) tt(= "interface") nl()
           Defines the pathname of the file containing the interface of a
            user-defined tt(Input) class. See bf(input)(3flexc++) for
            additional information about user-defined tt(Input) classes.
    it() bf(%interactive)nl()
           Generate an interactive scanner. An interactive scanner reads lines
            from the input stream, and then returns the tokens encountered on
            that line. The interactive scanner implemented by flc() only
            predefines the tt(Scanner(std::istream &in, std::ostream &out))
            constructor, by default assuming that input is read from
            tt(std::cin). See also the tt(INTERACTIVE SCANNER) section in
            bf(flexc++)(1). 
    it() bf(%lex-function-name) tt(= "funname") nl()
           Defines the name of the scanner class's member to perform the
            lexical scanning. If this directive is omitted the default name
            (tt(lex)) is used. Corresponding command-line option:
            tt(--lex-function-name).
    it() bf(%lex-source) tt(= "source") nl()
           Defines the pathname of the file to contain the scanner member
            tt(lex). Corresponding command-line option: tt(--lex-source).
    it() bf(%max-depth) tt(= depth) nl()
           Set the maximum inclusion depth of the lexical scanner's
            specification files to tt(depth). By default the maximum depth is
            set to 10. When more than tt(depth) specification files are used
            the scanner throws a tt(Max stream stack size exceeded)
            tt(std::length_error) exception. 
    it() bf(%no-lines) nl() 
           Do not put tt(#line) preprocessor directives in the file containing
            the scanner's tt(lex) function. If omitted tt(#line) directives
            are added to this file, unless overridden by the command line
            options tt(--lines) and tt(--no-lines).
    it() bf(%namespace) tt(= "namespace") nl()
           Define the scanner class in the namespace tt(namespace). By default
            no namespace is used. If this options is used the
            implementation header is provided with a commented out tt(using
            namespace) declaration for the requested namespace.  This
            directive is overridden by the tt(--namespace) command-line
            option.
    it() bf(%print-tokens) nl() 
           This option results in the tokens as well as the matched text to be
            displayed on the standard output stream, just before returning the
            token to tt(lex)'s caller. Displaying is suppressed again when the
            tt(lex.cc) file is generated without using this directive. The
            function showing the tokens (tt(ScannerBase::print__)) is called
            from tt(Scanner::print()), which is defined in-line in
            tt(scanner.h). Calling tt(ScannerBase::print__), therefore, can
            also easily be controlled by an option controlled by the program
            using the scanner object.
           This option does em(not) show the tokens returned and text matched
            by flc() itself when reading its input file(s). If that is what
            you want, use the tt(--own-tokens) option.
    it() bf(%s) tt(namelist) nl()
           The tt(%s) directive is followed by a list of one or more
            identifiers, separated by blanks. Each identifier is the name of
            an em(inclusive mini scanner).
    it() bf(%skeleton-directory) tt(= "path") nl()
           Use tt(path) rather than the default (e.g., tt(/usr/share/flexc++))
            path when looking for flc()'s skeleton files. Corresponding
            command-line option: tt(--skeleton-directory).
    it() bf(%target-directory) tt(= "path") nl()
           Generate files in tt(path) rather than in flc()'s input file's
            directory.
            The tt(%target-directory) option does not affect files that were 
            explicitly named (either as option or as directive).
    it() bf(%x) tt(namelist) nl()
           The tt(%x) directive is followed by a list of one or more
            identifiers, separated by blanks. Each identifier is the name of
            an em(exclusive mini scanner).
    )
