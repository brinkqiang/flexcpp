The vector tt(DFARow::d_finAcInfo) contains tt(FinAc) objects. Their data
members are shown in figure ref(DFAROWFIG). They are:
    itemization(
    itt(d_rule): the index of the rule using the LA operator;
    itt(d_accept): the em(accept count) at this point (the accept count is the
        number of transitions after observing the LA operator, it is
        tt(FinAc::PRE_A_STATE) for pre-accept tt(DFARow)s);
    itt(d_final): the final state accept count. It equals
        tt(FinAc::FINAL_NOT_SET) if undetermined; tt(FinAc::NOT_FINAL)
        if this is not a Final state; when tt(d_final >= 0) it represents the
        Final state accept count;
    itt(d_inc): a tt(bool) which is tt(true) if this is an em(incrementing
        Accept state): |TAIL| is incremented each time this state is reached
        (as with patterns like `tt(ab/a+)', where |TAIL| is incremented while
        processing the tt(a) symbols matching the tt(a+) pattern). See also
        the label(description below)(INCREMENTINGACCEPT).
    )

quote(TO DO: Why is there a vector of tt(FinAc) elements in a tt(DFARow)?)

subsubsect(processFinAc)

The tt(FinAc) elements are updated by tt(DFA::processFinAc). It visits all
tt(FinAc) objects of the tt(DFARow) and calls tt(DFA::processFinAc)
for each of them.

Each rule is only processed once by tt(processsFinAc). So if the same rule
is used in, e.g., different mini scanners or in different DFA states, then the
first occurrence results in it being processed. Since a rule, rather than a
DFA row, defines how its HEAD and TAIL are computed there is no need to
re-process a rule once it has been processed.

tt(processFinAc) determines the accept counts for the NFA
    states of a rule. These counts are determined once per state to prevent
    continuous repetition for repetitive patterns like 'tt(a+)'. The first
    state to receive an accept count is the rule's accept state (for a rule
    like tt(ab/cd), this results in NFA verb( 1--a--2--b--3--c--4--d--5 A )
    having the accept state at state 3).

    Because of restrictions in the way the LA operator may be used there's
    never a repetitive pattern from a post-A state back to a pre-A state, so
    accept counts can be determined starting at the NFA's accepting state.

    em(Accept counts) are determined as the number of transitions to reach a
    certain DFA row starting from the row holding the NFA's accepting state.
    It is the task of the doubly recursive function tt(DFA::propagateLAsteps)
    to determine the accept counts of the DFA state whose row-index was passed
    to it. 


lsubsubsect(PROPAGATELA)(DFA::propagateLAsteps)

tt(DFA::propagateLAsteps) operates as follows:
        itemization(
        it() It receives the rule's accepting state number and an (initial)
            accept count of 0. 
        it() Then, in preparation of the recursive calls the step count is
            incremented if the current state is not an empty edge. 
        it() As each state has two links (which may not both be used) the
            recursive calls follow these links, receiving the possibly 
            incremented stepcount. 
        it() When there are multiple routes to a given state then the accept
            count is set to the largest step count value.
        )

subsubsect(DFA::processRule) 

Once the LA steps have been determined tt(DFA::processRule) is called to
    determine the accept counts of LA-rules, starting at row 0 of the DFA.

        itemization( 
        itt(DFA::processRule) is an indirectly recursive function receiving a
            rule index; a DFA row index (initially 0); an indication whether
            its 'parent' row (i.e., the DFA row offering a transition to the
            current row was a Final state for the current rule (initially: not
            final)); and the number of accept steps so far (initially -1).
        it() At the DFA row currently under inspection it tries to locate the
            provided rule index in the DFA row's FinAc objects. 
        it() If found then that rule is an LA rule that is active in the
            current DFA row. It then calls tt(DFA::processRow) to determine
            that row's accept and final count for that particular rule,
            passing it the rule's tt(FinAc); rule index; DFA row index;
            parent final status and current tail size.
        )

subsubsect(DFA::processRow)

tt(DFA::processRow) is called from tt(DFA::processRule) and implements the
    core actions of the tail-size computation algorithm. It consists of two
    parts. In part I the rule's tt(FinAc) of the current row is updated,
    in part II the rows to which the current row may transit to are inspected.

    itemization(
   it() Part I is only executed if there's at least one post-A state present 
    in the set of NFA states represented by the current DFA row. If this holds
    true then the following steps are performed: 
       itemization(
       it() At the row for which this happens for the first time tailSize is
        set to 0. 
       it() Then, if the current row can be a final state for the rule that's
        currently under inspection its |TAIL| is determined. 
       it() If the |TAIL| was determined during an earlier phase of the
        algorithm, then --following the principle that |TAIL| should always be
        as small as possible-- |TAIL| is determined as the minimum of its
        current value and the current value of tailSize. 
       it() If |TAIL| hasn't been determined yet then it is set to
        tt(parentFinal), unless tt(parentFinal) is -1, in which case it is set
        to tt(tailSize). Thus, two consecutive final DFA states have identical
        |TAIL| values, as described in section ref(FINACALGO).
       )

   it() label(INCREMENTINGACCEPT) DFA rows may represent mere pre-A NFA
    states, mere post-A NFA states or a mixture of both. Once a DFA row is
    reached merely representing post-A NFA states |TAIL| must be incremented
    at each transition as there are no backlinks to DFA rows representing
    pre-A NFA states. If the set of tt(State)s defining a DFA row does not
    contain pre-A states the accept count of the current tt(FinAc) is set
    to incrementing, with an initial value equal to the maximum possible
    accept count when reaching this row for the first time. As a case in
    point, consider the regex and NFA shown in figure ref(INCACCEPTFIG).
       
        figure(images/incaccept)(Incrementing Accept counts)(INCACCEPTFIG)


    Here, once the set of states tt({2,4}) has been reached we have mere
    post-A states and the initial accept count of the DFA row representing the
    set tt({2,4}) is set to tt(2,incrementing). Furthermore, if this is also a
    final state |TAIL| must be equal to the eventual accept count.

    Since accept counts are incremented from here, there's no need to inspect
    further transitions from here. In this case processRow returns, not
    executing its 2nd part.

    Consider (see also tt(dfa/processrow.cc), near line 50):

    quote(
    An incrementing accept state is not a fixed final value. Is it necessary
    to set final's value?  Couldn't the code generator detect that this is a
    final state em(and) an incrementing Accept state and thus determine that
    |TAIL| will be the current accept count if this is the final DFA state for
    this rule?  In that case tt(final != NOT_FINAL) would be enough
    information for the code generator to decide what to do.)

   it() Part II: If processing continues the current row represents a
    mixed-A-state set. In this case the row's accept size is set to the
    current tail size, tail size is incremented and the 2nd part starts.

    tt(DFA::processRow)'s second part visits all transitions of the current
    row, passing them in sequence to the function tt(DFA::inspect), together
    with the current row and rule indices; the current Final state's |TAIL|
    value (which may be -1 if the current DFA state isn't a final state for
    the current rule); and the current (posibly incremented) tail
    size. 
    )

subsubsect(DFA::inspect)

tt(DFA::inspect) (indirect recursively) calls tt(processRule) if the
    transition is to a later (higher row index) row in the DFA than the row
    from where tt(DFA::inspect) was called. Back transitions can be skipped as
    their statuses were determined before, representing earlier positions in
    the NFA.

