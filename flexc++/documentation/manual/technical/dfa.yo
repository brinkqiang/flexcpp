The conversion from NFA to DFA is the job of the class tt(DFA) object
(cf. figure ref(DFAFIG))

    figure(images/dfa)(The DFA class data members)(DFAFIG)

The DFA needs uses the externally available rules, states and character ranges
and builds a matrix, called tt(d_row). 

Building the DFA from the NFA is the task of tt(DFA::build). 

Each row of tt(d_row) defines a state in the DFA. The Rule numbers of the
Rules defining a mini scanner received as tt(build)'s tt(vector<size_t>)
parameter. 

tt(DFA::build) initially stores the start states of the rules of its mini
scanner in its tt(d_stateSet[0])sups(th) element, which is a set (cf. figure
ref(DFAFIG1)). This is done by tt(DFA::fillStartSet)

    figure(images/dfa1)(Creating the start states for row 0)(DFAFIG1)

Next, the e-closure of this initial set of states is computed. The e-closure
algorithm is described in ASU's dragon book (1986, figure 3.26). It
essentially adds all states that can be reached from each element in the
current set of states on an empty transition. The e-closure is computed by
tt(States::eClosure).

At this point there is an element in tt(DFA::d_stateSet), but not yet an
element in tt(DFA::d_row). By adding a tt(DFARow) (see section ref(DFAROW)) to
tt(d_row) we associate a tt(DFARow) with an initial set of states. 

Once the new DFA has been added to tt(d_row) its transitions are probed by
tt(DFARow::transitions) (see section ref(DFAROW)).

bf(DFA::keepUniqueRows)

    Having determined the transitions tt(build) proceeds to remove
implied/identical rows, calling tt(DFA::keepUniqueRows). This latter function
visits each of the rows of the DFA, testing whether an existing row has the
same transitions and final state information as the current row. `Same
transitions' means that the transitions of the current (under inspection) row
are present in an earlier row; `same final state information' means that the
current row is a final state for the same rule(s) as an earlier row. In such
situations the current row can be merged with the earlier row, keeping the
earlier row. The (later) row can then be removed as transitions from it are
identical to those from the earlier row. This may happen, as the NFA
construction algorithm may define more empty edges than strictly necessary,
sometimes resulting in additional rows in the DFAs. As an example, consider
the pattern tt((a|ab)+/(a|ba)+), producing the DFA
    center(
    table(5)(llrc)(
    rowline()
    row(cell()cells(2)(Input Chars))
    row(cell(StateSet) ccell(a) ccell(b) ccell(Final) ccell(Accept))
    rowline(cell()cellsline(2)(4))

    row(cell(0)ccell(1))
    row(cell(1)ccell(2)ccell(3))
    row(cell(2)ccell(2)ccell(3)   cell(0:1))
    row(cell(3)ccell(4)ccell(5))
    row(cell(4)ccell(2)ccell(3)   cell(0:2))
    row(cell(5)ccell(6)cell()     cell()cell(0:++1))
    row(cell(6)ccell(7)ccell(5)   cell(0))
    row(cell(7)ccell(7)ccell(5)   cell(0))
    rowline()
    ))
    Rows 6 and 7 are identical, as are rows 2 and 4. For row 4 the (erroneous,
if |TAIL| should be as short as possible) |TAIL| = 2 is shown, resulting from
tt(aba) being interpreted as HEAD: tt(a) and TAIL: tt(ba). 

But when |TAIL| should be minimized tt(aba) should be interpreted as HEAD:
tt(ab) and TAIL tt(a), resulting in transitions 0 -> 1 -> 3 -> 2, with |TAIL|
= 1. This happens when row 4 is merged to row 2. Having merged the rows,
former transitions to the now removed rows must of course be updated to the
merging row. So row 3 must transit to 2 when receiving input symbol tt(a). The
member tt(shrinkDFA) handles the shrinkage of the DFA. In this example the
final DFA becomes:
    center(
    table(5)(llrc)(
    rowline()
    row(cell()cells(2)(Input Chars))
    row(cell(StateSet) ccell(a) ccell(b) ccell(Final) ccell(Accept))
    rowline(cellsline(2)(4))

    row(cell(0)ccell(1))
    row(cell(1)ccell(2)ccell(3))
    row(cell(2)ccell(2)ccell(3) cell(0:1))
    row(cell(3)ccell(2)ccell(4))
    row(cell(4)ccell(5)cell()   cell()cell(0:++1))
    row(cell(5)ccell(5)ccell(4) cell(0))
    rowline()
    ))

bf(processFinAc)

Once the final DFA has been constructed the Final and Accept information can
be computed. This is performed by tt(DFA::processFinAc).
This function visits all tt(FinAc elements at row 0
// 
// It calls processFinAc that picks up the rule nr from the FinAc object
// calling processRule to process the DFA for the current rule (for each rule
// using the LA operator this happends only once).
// 
// processRule checks whether the requested rule is available at the current
// DFA row and if so it calls processRule to set/inspect the FinAc for the
// given rule at the given DFA row.
//
// processRule calls processRow to do the actual work, calling inspect for
// each transition.

tt(processFinacInfo) for each of the 
operates on a row of the DFA matrix. See section ref(DFAROW)
for its description.











