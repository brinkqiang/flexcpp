The parser is called by tt(flexc++) as follows:
        verb(
    Parser parser(rules, states);
    parser.parse();
        )
The constructor performs no other tasks than initializing itself.
tt(Rules) and tt(states) are still empty at this point.

The tt(parse) function was generated by bisonc++. It's better understood from
the grammar description.

tt(parser/grammar): The grammar's start rule is
        verb(
    input:
        opt_directives          // directives. C(++) code now in a class
        section_delimiter mode_pattern
        opt_rules
    ;
        )

tt(parser/rules/rulesection): The directives are not covered here yet. A rule
is defined as:
        verb(
    rule_line:                      
        rule_definition '\n' mode_pattern
    ;
        )

tt(parser/rules/modeswitches:) A tt(mode_pattern) is a marker non-terminal
resetting the scanner to its pattern mode, allowing it to recognize the next
pattern (i.e., a regular expression that can be matched)

A tt(rule_definition) consists of a regular expression that can be matched (a
pattern). E.g., tt(a+b*). It is a tt(pattern_ws), i.e., a pattern followed by
white space, optionally followed by a block of bf(C++) code, eventually ending
in a newline. Here are its rules:

        verb(
    rule:
        pattern_ws BLOCK
        {
            d_rules.add(SemVal::downCast<PatternVal>(*$1).pair(), 
                        d_accept, d_scanner.block());
        }
    |
        pattern_ws
        {
            d_rules.add(SemVal::downCast<PatternVal>(*$1).pair(), d_accept);
        }
    ;
        )

Blocks are defined link(here)(BLOCKS); the tt(Rules) class is described
link(here)(RULES); patterns are described link(here)(PATTERNS).








