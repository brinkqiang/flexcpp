Once all regular expressions have been parsed and standard LOP-expressions
were encountered the catch-all rule is added to the existing rules (by
tt(Rules::processCatchAllRule)). 

The catch-all rule is the last rule, injected by the scanner once it has
reached the end of its input. It is not inspected for viability, and is stored
inside the tt(Rules) object in a separate tt(Rule d_catchAll) object.

Next the LOP-rules' start conditions are defined.

At this point all user-defined rules are known, and the user-defined start
conditions are also known (as the parser has processed the tt(%x) and tt(%s)
directives). Therefore, all start conditions which are required for handling
standard LOP-rules have index values exceeding the number of user-defined
start conditions. When a standard LOP-rule was encountered by the parser,
tt(Parser::lookahead) increased its tt(d_lopStartCondition) by 2, and so at
this point tt(d_lopStartConditions - d_rules.size()) start conditions are
defined.

These start conditions are for internal use only. Their names are not made
available in the generated tt(ScannerBase.h) header file. They start with a
blank space, which cannot be used by user-called tt(begin) statements.


