Indices at the end of the tt(s_dfa) rows refer to rows in the tt(s_finAcInfo)
array, generated by tt(Generator::outFinAcs) (file tt(generator/outfinacs)).
The first index holds the first relevant tt(s_accept) row, the
second index holds the index of the row that is not relevant anymore. If
tt(begin == end) then this row does not represent an accepting or final state.


The columns of this matrix, labeled tt(R, F, A) and tt(I), indicate:
itemization(
itt(R): the rule number that was matched if there is no continuation for the
    next input-range value. If this rule is matched its action block is
    executed next.

itt(F): the final state indicator:

    If it equals -2 the state is not a Final state;

    It if equals -1  then the matched text is
    accepted as-is (the rule did not use a lookahead operator);

    If its value is non-negative then it is the (initial) em(accept count) of
    this state, which is a final state. In this case the LA operator has been
    used and the last `final accept count' characters should be pushed back to
    the input stream

itt(A) the final state's accept count. The accept count is the number of
    transitions after observing the LA operator (see also section
    ref(LOOKAHEAD)). If it is 0 it represents tt(FinAcInfo::PRE_A_STATE)), and
    it can be ignored as this is a state before reaching the LA operator.
    If it is -1 the accept count should be handled as specified before


itt(I) This is a bool which is true if this is an em(incrementing
    Accept state): The accept count (the length of the tail, following the LA
    operator) is incremented each time this state is reached (as with patterns
    like `tt(ab/a+)', where the tail's length is incremented while processing
    the symbols matching the a+ pattern).
    )


Here is an example of rules, transition matrix and tt(s_finAcInfo) array:
There are three rules, two using the LA operator:
        verb(
    abd+/def+
    abd+/d
    abd+
        )

The matching transition matrix shows that states 3 through 6 have FinAc
vectors associated with them (discussed below):
        verb(
    {-1, 1,-1,-1,-1,-1,-1,-1,-1,   0, 0},  // 0
    {-1,-1, 2,-1,-1,-1,-1,-1,-1,   0, 0},  // 1
    {-1,-1,-1,-1, 3,-1,-1,-1,-1,   0, 0},  // 2
    {-1,-1,-1,-1, 4,-1,-1,-1,-1,   0, 1},  // 3
    {-1,-1,-1,-1, 4, 5,-1,-1,-1,   1, 3},  // 4
    {-1,-1,-1,-1,-1,-1, 6,-1,-1,   3, 4},  // 5
    {-1,-1,-1,-1,-1,-1, 6,-1,-1,   4, 5},  // 6



    {-1, 1,-1,-1,-1,-1,-1,-1,-1,   0, 0},  // 0 a
    {-1,-1, 2,-1,-1,-1,-1,-1,-1,   0, 0},  // 1 b
    {-1,-1,-1,-1, 3,-1,-1,-1,-1,   0, 0},  // 2 d
    {-1,-1,-1,-1, 4,-1,-1,-1,-1,   0, 1},  // 3 abd+: match 2, full length
                                             { 2,-1,-1, 0},

    {-1,-1,-1,-1, 4, 5,-1,-1,-1,   1, 3},  // 4 abcd/+d
                                                no cont.: match rule 2
                                                cont: accept count = 1
                                            { 1, 1, 1, 0},
                                            { 2,-1,-1, 0},

    {-1,-1,-1,-1,-1,-1, 6,-1,-1,   3, 4},  // 5
                                                no final state, acc.
                                                count: 2, incrementing
                                            { 0,-2, 2, 1},

    {-1,-1,-1,-1,-1,-1, 6,-1,-1,   4, 5},  // 6
                                                
                                            { 0,-1,-1, 0},
        )

The FinAc matrix is:
        verb(
     { 2,-1,-1, 0},
     { 1, 1, 1, 0},
     { 2,-1,-1, 0},
     { 0,-2, 2, 1},
     { 0,-1,-1, 0},
        )
itemization(
it() Its first row indicates what may happen in state 3: if there's no
    continuation in this state (i.e., after recognizing a, b, d then rule 2 is 
    matched, recognizing tt(abd)

it() Its second and third rows indicate what may happen in state 4. This
    state is reached after matching tt(abdd). While more d's are matched we
    stay in state 4. If an tt(e) character is read, transit to state
    5. Otherwise, there is a choice between matching rules 1 or 2. Since the
    lexer uses greedy matching it will match rule 2, and matching rule 1,
    having a tail of 1     character is ignore.

it() State 5's FinAc vector is tt({ 0,-2, 2, 1}). Here we've recognized 
    tt(abd+deIt indicates that this is
    not a final state, and that the current accept count equals 2, and that
    this is an incrementing accept state.


    All rows are final states for rule 0. The first row has an accept count of
1 and is a final state if there's no continuation possible from the matching
state. 

    The second row is an incrementing accept state. While transitions are in
accept states the accept count, starting at 1, is incremented.

    The third row represents a plain accepting state. No LA operator.

