Indices at the end of the tt(s_dfa) rows refer to rows in the tt(s_finAcInfo)
array, generated by tt(Generator::outFinAcs) (file tt(generator/outfinacs)).
The first index holds the first relevant tt(s_accept) row, the
second index holds the index of the row that is not relevant anymore. If
tt(begin == end) then this row does not represent an accepting or final state.

quote(
    TODO: Why 2 values? why not -1: not a final/accepting state and otherwise
    the index of the relevant row in finAcInfo?
)

The columns of this matrix, labeled tt(R, F, A) and tt(I), indicate:
itemization(
itt(R): the rule number that was matched if there is no continuation for the
    next input-range value. If this rule is matched its action block is
    executed next.

itt(F): the final state accept count. 
    If it equals -2 (representing tt(FinAcInfo::NOT_FINAL)) then the current
    state is not a (fixed sized?) Final state; 

    It if equals
    -1 (representing tt(FinAcInfo::FINAL_NOT_SET)) then the matched text is
    accepted as-is, as the rule did not use a lookahead operator.

    If its value is non-negative then it is the em(accept count) of this
    state, which is a final state. In this case the LA operator has been used
    and the last `final accept count' characters should be pushed back to
    the input stream

itt(A) the final state's accept count. The accept count is the number of
    transitions after observing the LA operator (see also section
    ref(LOOKAHEAD)). If it is 0 it represents tt(FinAcInfo::PRE_A_STATE)), and
    it can be ignored as this is a state before reaching the LA operator.
    If it is -1 the LA operator was not used.

itt(I) This is a bool which is true if this is an em(incrementing
    Accept state): The accept count (the length of the tail, following the LA
    operator) is incremented each time this state is reached (as with patterns
    like `tt(ab/a+)', where the tail's length is incremented while processing
    the symbols matching the a+ pattern).
    )


Here is an example of a tt(s_finAcInfo) array:
        verb(
    FinAcInfo const ScannerBase::s_finAcInfo[] =
    {
           R  F  A  I
         { 0, 1, 1, 0},
         { 0,-2, 1, 1},
         { 0,-1,-1, 0},
    };
        )
    All rows are final states for rule 0. The first row has an accept count of
1 and is a final state if there's no continuation possible from the matching
state. 

    The second row is an incrementing accept state. While transitions are in
accept states the accept count, starting at 1, is incremented.

    The third row represents a plain accepting state. No LA operator.
