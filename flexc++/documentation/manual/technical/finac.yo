Indices at the end of the tt(s_dfa) rows refer to rows in the tt(s_finAcInfo)
array, generated by tt(Generator::outFinAcs) (file tt(generator/outfinacs)).
The first index holds the first relevant tt(s_accept) row, the
second index holds the index of the row that is not relevant anymore. If
tt(begin == end) then this row does not represent an accepting or final state.


The columns of this matrix, labeled tt(R, FA) and tt(I), indicate:
itemization(
itt(R): the rule number that was matched if there is no continuation for the
    next input-range value. If this rule is matched its action block is
    executed next.

itt(F): the final state indicaction or accept count 
    If it equals -2 is not a Final state, nor an accepting state.; 

    It if equals -1  then the matched text is
    accepted as-is (the rule did not use a lookahead operator);

    If its value is non-negative then it is the (initial) em(accept count) of
    this state, which is a final state. In this case the LA operator has been
    used and the last `final accept count' characters should be pushed back to
    the input stream

itt(A) the final state's accept count. The accept count is the number of
    transitions after observing the LA operator (see also section
    ref(LOOKAHEAD)). If it is 0 it represents tt(FinAcInfo::PRE_A_STATE)), and
    it can be ignored as this is a state before reaching the LA operator.
    If it is -1 the accept count should be handled as specified before


itt(I) This is a bool which is true if this is an em(incrementing
    Accept state): The accept count (the length of the tail, following the LA
    operator) is incremented each time this state is reached (as with patterns
    like `tt(ab/a+)', where the tail's length is incremented while processing
    the symbols matching the a+ pattern).
    )


Here is an example of rules, transition matrix and tt(s_finAcInfo) array:

Rules:
        verb(
    abd+/def+
    abd+/d
    abd+
        )

Transition matrix:
        verb(
    {-1, 1,-1,-1,-1,-1,-1,-1,-1,   0, 0},  // 0
    {-1,-1, 2,-1,-1,-1,-1,-1,-1,   0, 0},  // 1
    {-1,-1,-1,-1, 3,-1,-1,-1,-1,   0, 0},  // 2
    {-1,-1,-1,-1, 4,-1,-1,-1,-1,   0, 1},  // 3 abd+: match 2, full length
                                             { 2,-1,-1, 0},

    {-1,-1,-1,-1, 4, 5,-1,-1,-1,   1, 3},  // 4 abcd/+d
                                                no cont.: match rule 2
                                                cont: accept count = 1
                                            { 1, 1, 1, 0},
                                            { 2,-1,-1, 0},

    {-1,-1,-1,-1,-1,-1, 6,-1,-1,   3, 4},  // 5
                                                no final state, acc.
                                                count: 2, incrementing
                                            { 0,-2, 2, 1},

    {-1,-1,-1,-1,-1,-1, 6,-1,-1,   4, 5},  // 6
                                                
                                            { 0,-1,-1, 0},
        )

Finac matrix:
        verb(
     { 2,-1,-1, 0},
     { 1, 1, 1, 0},
     { 2,-1,-1, 0},
     { 0,-2, 2, 1},
     { 0,-1,-1, 0},
        )



    All rows are final states for rule 0. The first row has an accept count of
1 and is a final state if there's no continuation possible from the matching
state. 

    The second row is an incrementing accept state. While transitions are in
accept states the accept count, starting at 1, is incremented.

    The third row represents a plain accepting state. No LA operator.

