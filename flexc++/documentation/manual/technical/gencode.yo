Code is generated by an object of the class tt(Generator). 
The generator generates the following files (using default names, all defaults
can be overruled by directives and options):

itemization(
itt(Scannerbase.h.) This file defines the scanner's base class. It is always
rewritten and declares data members used by the scanner.

itt(Scanner.h.) This file represents the generated scanner's interface. It
inherits from tt(ScannerBase) and is written only if not existing. 

itt(lex.cc) This file contains the implementation of the scanner function and
any support functions it may need. This file is always rewritten.
)

Each of these three files has a skeleton, found in tt(/usr/share/flexc++)
which is copied to the generated code, embedding the following elements into
the generated files:

itemization( 
it() The em(static data) are inserted into the generated tt(lex.cc)
file. Static data are not used by other components of the scanner, and could
be embedded in the anonymous namespace;

it() The em(actions) are inserted into the generated tt(lex.cc) as well.

it() The em(declarations) are inserted into the generated tt(Scannerbase.h)
file. 
)

The member tt(genLex) generates the lexer file tt(lex.cc). It recognizes
tt($insert) lines starting in column 1 and performs the matching action,
inserting appropriate elements into the generated file.

Other generating members act similarly:

The member tt(genBase) generates the scanner base file tt(Scannerbase.h), the
member tt(genScanner) generates tt(Scanner.h).



The code generated by tt(flexc++) must read input, match the input with some
regular expressin and return the associated token. A catch-all escape is
provided by the implicitly provided rule echoing all non-matched input to the
standard output stream.

The generated code consists of these parts:
    itemization(
    it() The character-table (actually: range-table). See section
        ref(RANGETAB). 

    it() The DFAs are generated by tt(Generator::dfas). 
    )

    For each of the DFAs the function tt(Generator::dfa) is called. 

        itemization(
        it() The function tt(Generator::dfa) receives as its first argument a
tt(DFAs::Pair) (see figure ref(DFASFIG)), containing the name of the mini
scanner associated with the DFA and the DFA itself. The member function first
checks whether the DFA has already been processed. This only happens for
tt(INITIAL), and the current test is rather blunt by the function tt(dfa)
calling tt(std::find).

    If this DFA has not yet entered the tt(s_dfa[]) array then
        itemization(
        it() The name of the current mini scanner is stored in tt(startStates)
(to allow checking for repetitive handling);
        it() The row number of the first row of the current DFA in tt(s_dfa)
is saved in the vector tt(dfaOffsets);
        it() tt(Generator::dfaRow) is called for each row of the DFA (see
figure ref(DFAROWFIG)). This latter function writes the vector of DFA rows to
transit to (i.e., rows relative to the current DFA's start row, so not the
actual rows in tt(s_dfa)) for each of the character ranges (calling
tt(Generator::dfaTransitions)), followed by the number of the rule that is
matched if the rule represents a final state not necessarily at BOL and the
number of the rule that is matched if the rule represents a final state at
BOL. Values -1 are used if no such rules exist for the state represented by
the current row.
        )
    it() The function tt(Generator::declarations)
            quote(TO DO)
    it() The function tt(Generator::actions)
            quote(TO DO)
    )









