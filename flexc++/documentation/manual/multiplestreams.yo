lchapter(multiplestreams)(Multiple input streams)

Some scanners (such as those which support `include' files) require reading
from several input streams. Usually, one switches streams when a directive
like tt(#include) is encountered. Flc() offers two ways of switching streams:

itemization(
    it() First, a directive like tt(#include) may be defined. In this case,
    processing the current file is suspended and processing continues at the
    file mentioned in the directive. When finished processing this included
    file, the scanner switches back to the suspended input stream. In this
    case streams are pushed on a stack when encountering a stream switching
    directive and popped off the stack once the current file has completely
    been processed.
    it() Second, the user may request the scanner to switch to another stream.
    Optionally, the user may request to switch back. In this case, the user is
    completely responsible for all stream-related bookkeeping. The scanner
    merely provides a means to switch from one stream to another.
)

Users may want to store information related to a certain stream, beside the
information strictly required by flc() (an tt(istream) pointer and tt(size_t)
for the line numbering). For example, a user may want to use the name of the
file that is currently being processed. Flc() provides the following mechanism
for storing this additional information.

The user must supply a class with certain characteristics (see below) and tell
flc() the name and location of this class. When switching streams, a
dynamically allocated pointer to this class must be provided.

sect(StreamInfo)

The class which must be provided by the user is used to instantiate the
template class tt(ScannerTemplate), it's template type parameter is called
tt(StreamInfo). The tt(Scanner) class is derived from tt(ScannerBase), which
is derived from this instantiated tt(ScannerTemplate).

Classes which can be used as a tt(StreamInfo) em(must) have at least the
following properties:

itemization(
    it() Have a default constructor. By convention, the default constructor
    should associate the tt(StreamInfo) with tt(cin)
    it() Have a member tt(connect(StreamAdapter *)). This member ...
    it() Have a member tt(resume(StreamInfo, size_t)). ...
    it() Close the stream upon destruction.
)


Flc() provides two tt(StreamInfo) classes for common use cases, but the user
is given the option to provide it's own class. The classes flc() provides are
in the namespace tt(StreamSwitching) (which is optionally in a user-configured
namespace with the tt(namespace) option).

description(
    dit(tt(StreamInfo)) This class is used by default. It has a default
    constructor, a constructor expecting the name of a file to open or a
    pointer to an istream (which tt(StreamInfo) will delete). The tt(connect)
    member will set the line number to 1.
    dit(tt(LineStreamInfo)) This class is derived from tt(StreamInfo) and has
    the same constructors. It furthermore makes sure that line numbering is
    not reset: when switching streams, the new file will begin numbering lines
    where the old, suspended stream left off. When this file is processed
    completely, the tt(resume) method sets the line number of the suspended
    stream to the line number of the current file.
)

For easy access to the current tt(StreamInfo) object, tt(ScannerTemplate)
defines a tt(typedef) tt(StreamInfoType). This has the advantage that the user
has only one place where the name of the tt(StreamInfo) class is configured.

sect(Public members)

The following members are available for switching streams:

description(
    dit(tt(void pushStreamInfo(StreamInfo *si))) This member pushes the
    current stream on the scanner's stream stack and initializes the scanner's
    buffer with the new stream.
    dit(tt(void popStreamInfo())) This member pops a previously pushed stream
    off the scanner's stream stack and resets the scanner's buffer to the
    popped info.nl()Called by default on tt(EOF), unless the user provides an
    action for the tt(<<EOF>>) pattern.

    dit(tt(StreamBuffer const switchStream(StreamInfo *si))) This member
    returns the current tt(StreamBuffer) and continues processing the stream
    defined by the tt(StreamInfo) object. All bookkeeping with regards to
    streams is now handled by the user.
    dit(tt(void switchStream(StreamBuffer const &sb))) This member reverts
    processing to a stream buffer saved previously by tt(switchStream)'s
    caller.
)

sect(Option directives)

There are two option directives which configure the name and location of the
class:

description(
    dit(tt(streaminfoclassname)) Name of the tt(StreamInfo) class.
    dit(tt(streaminfoinclude)) The file containing the tt(StreamInfo) class
    (included in tt(scannerbase.h)).
)

sect(Examples)

subsect(Default StreamInfo)

The following example uses the default tt(StreamSwitching::StreamInfo) class:
line numbering will be set to 1 when processing the include.

verb(%x include
%%
"#include " begin(include);
[^#\n]*     std::cout << streamInfo().name() << ":" << lineno() << ": " << d_match << std::endl;
\n          // ignore

<include>[^ \n]* {
                std::cout << "Including " << d_match << ".\n";
                begin(INITIAL);
                pushStreamInfo(new Scanner::StreamInfoType(d_match.c_str()));
            }
)

Should one desire em(not) to reset line numbering, include the following line
at the top of the lexer file:
verb(%option streaminfoclassname="StreamSwitching::LineStreamInfo")

The interesting stuff happens in the tt(include) start condition. A new
tt(StreamInfoType) is pushed onto the streams stack. Flc() will automatically
pop the stream once tt(EOF) is reached.

subsect(User supplied StreamInfo)

The next example uses a tt(StreamInfo) which is supplied by the user:
tt(MyStreamInfo). It acts the same as tt(StreamSwitching::LineStreamInfo), but
shows how to include ones own tt(StreamInfo) class.

verb(#ifndef INCLUDED_MYSTREAMINFO_H
#define INCLUDED_MYSTREAMINFO_H

#include "scannerbase.h"

class MyStreamInfo: public StreamSwitching::StreamInfo
{
    ScannerTemplate<MyStreamInfo>::StreamAdapter *d_ptr;

    public:
        MyStreamInfo()
        {}

        MyStreamInfo(char const *name)
        :
            StreamInfo(name)
        {}

        MyStreamInfo(std::istream *in)
        :
            StreamInfo(in)
        {}

        void connect(ScannerTemplate<MyStreamInfo>::StreamAdapter *ptr)
        {
            d_ptr = ptr; // store for resume
            ptr->in = d_in;
            ptr->lineno = ptr->lineno;
        }

        void resume(MyStreamInfo const &streamInfo, size_t lineno)
        {
            d_ptr->lineno = lineno;
        }
};

#endif
)

The corresponding lexer file should then be:

verb(%option streaminfoclassname="MyStreamInfo" streaminfoinclude="mystreaminfo.h"
%x include
%%
"#include " begin(include);
[^#\n]*     std::cout << streamInfo().name() << ":" << lineno() << ": " << d_match << std::endl;
\n          // ignore

<include>[^ \n]* {
                std::cout << "Including " << d_match << ".\n";
                begin(INITIAL);
                pushStreamInfo(new Scanner::StreamInfoType(d_match.c_str()));
            }
)

As can be seen, the difference with the previous example is only the first
line with the two option-directives.

subsect(Switching streams with switchStream)

To use the raw stream switching facilities, the scanner has two members
available: tt(switchStream(StreamInfo *)) and tt(switchStream(StreamBuffer
const &)). The following example shows how to use these members. It maintains
a stack itself, the following member should be added to tt(scanner.h) once it
is generated: verb(std::stack<StreamBuffer> d_stack;)

The lexer file should then look like:

verb(%x include
%%
"#include " begin(include);
[^#\n]*     std::cout << streamInfo().name() << ":" << lineno() << ": " << d_match << std::endl;
\n          // ignore
<<EOF>>     {
    if (d_stack.size() < 1)
        return 0;
    std::cout << "Popping!\n";
    switchStream(d_stack.top());
    d_stack.pop();
}

<include>[^ \n]* {
    std::cout << "Including " << d_match << ".\n";
    begin(INITIAL);
    StreamBuffer const sb = switchStream(new Scanner::StreamInfoType(d_match.c_str()));
    d_stack.push(sb);
}
)

Now the interesting stuff happens both in the action for the tt(<<EOF>>)
pattern as well as in the tt(include) start condition. In tt(<include>), the
stream is switched to the new file and the old tt(StreamBuffer) is saved. Note
that tt(switchStream) returns a tt(const) copy: one should not alter this
object in any way, it contains information required for tt(lex()). This copy
is then pushed onto a stack.

Once tt(EOF) is reached, and there is nothing left on the stack, scanning is
finished. When there are suspended streams however, the current stream is
switched to the last suspended file and the stack is reduced. Scanning
continues.
