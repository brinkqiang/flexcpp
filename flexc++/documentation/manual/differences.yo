DEFINEMACRO(nosupport)(3)(\
    it() ARG1
    description(
        dit(Purpose:) ARG2
        dit(Flc() alternative:) ARG3
    )\
)

lchapter(differences)(Differences with flex/flex++)
Although flc() tries to be as much compatible with flex as possible, there are
some differences. This chapter provides a quick overview for the users already
familiar with flex.

lsect(code_blocks)(Format of the input file)

In flex it is possible to provide initialising code in the definition
section (see section ref(definitionsection)) and as the first lines in the
rules section.

Flc() does not support these code blocks. Since flc() generates a class with
appropriate header files, there are other means to include code in your
scanner. See also lref(generated files)(files) below.

Flc() also does not support a last `user code' section, where additional code
can be placed to be copied verbatim to the source file. A second section 
delimiter (%%) is therefore considered a syntax error.

There are two reasons for dropping support of these code blocks. First, 
the format of the lexer file becomes simpler. Second, the alternatives to
the code blocks are actually preferred. With flex one would use code blocks
before the rules to declare local variables that are used in some of the 
actions. With flc() it is possible to use data members of the scanner class
for this. With flex the third section of the lexer file could be used
to define helper functions. With flc() helper methods may be
defined in the scanner class. Below we list the differences between flex
and flc(). We provide suggestions for flc() solutions to problems that
were addressed by flex features that we no longer support.

Sections ref(diffdef), ref(diffrules) and ref(diffusercode) provide a list of
items which are no longer supported in flc() and the suggested solution.

lsubsect(diffdef)(Definition section)

itemization(
    nosupport(tt(%top) block, copies code to top of yylex.cc.)
        (Define macros or include files.)
        (Include header files in scanner.ih.)
    nosupport(Indented text or tt(`%{ ... %}') blocks copied verbatim to
            yylex.cc)
        (Can be used for helper code)
        (Member functions and data members of scanner class may be defined.)
    nosupport(An unindented c-comment (tt(`/* ... */')) is copied to yylex.cc)
        (Commenting helper code.)
        (Any comments outside actions are ignored, they are part of the lexer.)
)

lsubsect(diffrules)(Rules section)
itemization(
	nosupport(Indented text or tt(`%{ ... %}') blocks before first rule copied
            to the top of the function body of yylex.cc)
		(Declare local variables for NOEXPAND(yylex)().)
		(Use data members to keep track of state, or if you want to execute
			some code everytime NOEXPAND(lex)() is called, redefine
			NOEXPAND(lex)() to do more than just call the generated function
			NOEXPAND(lex__()).)
	nosupport(Other indented text or tt(`%{ ... %}') blocks are copied
            to the output, but meaning is ill-defined and compiler errors may
            result.)
		(POSIX compliance)
        (As of now, for the format of the input file we are not fully POSIX
            compliant.)
)

lsubsect(diffusercode)(User code section)

itemization(
	nosupport(The entire last section is copied to yylex.cc verbatim)
		(defining companion routines)
		(define member functions in scanner class)
)

lsect(diffpatterns)(Patterns)

The most important difference in behaviour with regard to patterns is 
the fact that flc() can actually match the empty string. For example,
the regular expression tt(a*) matches zero or more tt(a)'s. Thus, it
should also match the empty string. In flex, it does not. Currently,
in flexc++, it does. This means that a lexer file with only the pattern
tt(a*) in it, and a 'b' on the input will cause flc() to loop forever.
Therefore, care must be taken with patterns that match the empty string.

Not all patterns that are supported by flex are yet supported by flc().
Notably, flc() does not yet support certain flags in regular expressions,
e.g. a flag that makes the regular expression case insensitive, or a flag
that allows whitespace in a regular expression.

Another small difference in the patterns is that in a named pattern,
defined in the definion section, we do not allow the lookahead operator (`/')
or the begin anchor operator (`^'). That is because we treat the name expansion
as a group if it appears in a pattern in the rule section. Since groups may
occur any number of times in a regular expression but a lookahead operator or
a begin anchor operator only once, we do not accept them in a name definition.

lsect(files)(Generated files)

Flc() generates more files than flex does. While flex only generates a
tt(lex.yy.cc), flc() generates a number of header files and a source file:
tt(scanner.h), tt(scanner.ih), tt(scannerbase.h), and tt(lex.cc). Both
tt(scannerbase.h) and tt(lex.cc) are overwritten when prog() is invoked.

The other two files (tt(scanner.h) and tt(scanner.ih)) are only generated the
first time prog() is called. These files can be used to add additional code
to. If you want to use a namespace for your actions, for instance, a tt(using
namespace) directive can be added to tt(scanner.ih).

lsect(commentdiff)(Comments)
Flc() is a bit more flexible in taking comments, for more information see
section ref(comments). Also, besides multiline comments, end of line
comments are also supported.

lsect(functions)(Functions and macros)

Since Cpp() supports the concept of namespaces, the tt(yy)-prefix for every
member and macro is no longer needed. Most functions can now be used without
the prefix. Also, because flc() generates a scanner class, instead of macros
often member functions of the scanner class may be used.  See the conversion
table below.

table(3)(lll)(
    row(cell(bf(flex))
        cell(bf(flc()))
        cell(bf(flc()) alternative)
    )
    row(cell(tt(yylex()))
        cell(tt(lex()))
    )
    row(cell(tt(YYText()))
        cell(tt(text()))
        cell(tt(match()))
    )
    row(cell(tt(YYLeng()))
        cell(tt(leng()))
    )
    row(cell(tt(ECHO))
        cell(tt(ECHO()))
    )
    row(cell(tt(yymore()))
        cell(tt(more()))
    )
    row(cell(tt(yyless()))
        cell(tt(less()))
    )
    row(cell(tt(BEGIN startcondition))
        cell(tt(begin(startcondition)))
    )
	row(cell(tt(YY_AT_BOL))
		cell(tt(atBol()))
	)
	row(cell(tt(yy_set_bol(at_bol)))
		cell(tt(setBol(bool atBol)))
	)
)

The member functions in the flc() column above are either members of
tt(Scanner) or one of it's base classes. Also note that flc() no longer uses
macros and all member functions can be used from either actions or other
member functions.

Flex also offers macros that flc() no longer supports. We list them here,
along with their purpose and suggestions for alternative solutions with flc().

itemization(
	nosupport(tt(YY_USER_ACTION) and tt(yy_act))
		(run before exuting an action, yy_act contains rule number)
		(modify wrapper function executeAction, which receives a state
            number corresponding to an accepting state in the finite automaton
            that corresponds to the rule that matched)
	nosupport(tt(YY_NUM_RULES))
		(the number of rules in the lexer file)
		(Not yet implemented)
	nosupport(tt(YY_USER_INIT))
		(provide an action that is executed before initializing scanner)
		(add or modify a constructor of the scanner class)
	nosupport(tt(yy_set_interactive))
		(before scanning a buffer, set if it is interactive or not)
		(Not yet implemented)
	nosupport(tt(YY_BREAK))
		(contains the tt(break) statement in the tt(switch) statement that
            contains all actions. It is suggested that C++ programmers might
            redefine it to nothing, and manually make sure that all actions in
            the lexer have either a break or a return statement. The reason
            being that otherwise the compiler might give a warning that the
            break statement is unreachable because of the return statement
            above it.)
		(Not implemented, and no plans to implement it, we do not get
            such warnings with tt(g++ -pedantic). We would be glad to hear if
            you experience problems.)
)

sect(Multiple input streams)

Flc() differs completely from flex in how it handles multiple input streams.
The method for stream switching is described in full in
section ref(multiplestreams).
