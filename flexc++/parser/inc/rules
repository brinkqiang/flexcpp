    // there may be no rules
    // the scanner skips blanks, but returns '\n'
rules:
    rules rule
|
    // empty
;

block:
    BLOCK
    {
        block();
    }
;

    // each rule ends in a '\n'
rule:                      
    rule_def '\n'       
;                               
                                
rule_def:
    // only an empty line is OK
|
    // recovery from errors is OK: continue at the next line
    error       
|
    // the scanner may return this token on incomplete tokens, like quotes
    // missing the closing '
    ERR error
|
        // just regular expressions, without an action block
    regex_list 
|
        // the scanner returns a block if it encounters a non-blank character
        // on a line after ws, unless the character is a '|'
    regex_list block    
        { cout << "BLOCK\n"; }
|
    miniscanner_block
|
    EOF_PATTERN
|
    EOF_PATTERN block
;

    // series of regexes, separated by '|' at the end of lines. E.g.,
    // regex1   |
    // regex2   |
    // regex3
    //
    // ORNL is returned at '| ws \n'
regex_list:
    regex_list ORNL regex_list
        {cout << "ORNL\n";}
|
    simple_regex
;

        // Regex in the form: <miniscanner>regex, The <miniscanner> is
        // optional
simple_regex:       
    miniscanner basic_regex
        {cout << "<MINI>RE\n";}
|
    basic_regex
;

basic_regex_list:
     basic_regex_list ORNL basic_regex_list
|
     basic_regex
;

basic_rules:
    basic_rules basic_rule
|
    // empty
;

    // each rule ends in a '\n'
basic_rule:                      
    basic_rule_def '\n'       
;                               
                                
basic_rule_def:
    // empty
|
    basic_regex_list 
|
    basic_regex_list block    
|
    EOF_PATTERN
|
    EOF_PATTERN block
;

miniscanner_block:
    miniscanner '{' basic_rules basic_rule_def '}'
;

miniscanner:
    '<' miniscanner_specs '>' 
        {cout << "MINI\n";}
;

miniscanner_specs:
    '*'
|
    miniscanner_list
;

miniscanner_list:
    miniscanner_list ',' identifier
|
    identifier
;

    // a basic_regex is a regex, possibly with LA operator
    // the handler must verify whether the regex contains ^ and $ symbols
    // within the regex, for which a warning must be issue: ^, $ treated as
    // normal characters
basic_regex:
    p_regex
|
    p_regex '/' p_regex 
        {cout << "LA\n";}
;

    // the p_regex is a print-wrapper around regex
p_regex:
    regex
        {cout << "RE\n";}
;

    // a regex is any regular expression, not having a LA operator
    // It may have ^ and $ symbols
regex:
    combi_chars
|
    regex regex %prec CHAR
|
    regex '|' regex
        { cout << "OR\n"; }
|
    '(' regex ')'
|
    regex quantifier
        { cout << "QTY\n"; }
|
    characterclass
        { cout << "CLASS\n"; }
;

quantifier:
    '*'
|
    '+'
|
    '?'
|
    '{' interval '}'
;

interval:
    decimal
|
    decimal ',' decimal
|
    decimal ','
;
    
decimal:
    DECIMAL
;

characterclass:
    characterclass CC_PLUS characterclass
|
    characterclass CC_MINUS characterclass
|
    cc_set
;
 
cc_set:
    cc_start cc_contents cc_end
|
    cc_negated cc_contents cc_end
;

cc_start:
    CC_START
    cc_contents_m
;

cc_negated:
    CC_NEGATED
    cc_contents_m
;

cc_end:
    ']'
    regex_block_m
;

cc_contents:
    cc_contents cc_element
|
    cc_element
;

cc_element:
    combi_chars
|
    PREDEFINED_CLASS
|
    cc_char
;

    // characters handled identically within a character-set
cc_char:
    '/'
|
    '|'
|
    '('
|
    ')'
|
    '*'
|
    '+'
|
    '?'
|
    '{'
|
    '}'
|
    '<'
|
    '>'
|
    '['
;

    // elements may need to be split between cc_element and regex
    // if their handling turns out to be special
combi_chars:
    STRING
|
    decimal
|
    ESCAPE_SEQUENCE
|
    identifier
|
    CHAR
|
    '.'
|
    ','
|
    '^'
|
    '$'
|
    '='
|
    '-'
|
    '\''
;


