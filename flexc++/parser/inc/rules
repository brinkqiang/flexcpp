        // regex in the form: <miniscanner>(opt) regex
_optMs_regex:       
    ms_spec regex
    {   // following a <ms>regex, reset the ms back to INITIAL
        d_rules.resetStartConditions();
    }
|
    regex
;

    // series of _optMs_regexes, separated by '|' at the end of lines. E.g.,
    // _optMs_regex1   |
    // _optMs_regex2   |
    // _optMs_regex3
    // (ORNL is returned at '| {OPTBL} \n')
    // at ORNL any previously set ms-spec ends, and is back to INITIAL

_optMs_regex_list:                              // after ORNL continue parsing
    _optMs_regex_list ORNL nl_reset _optMs_regex_list  // at a new line
    {                                              
        $$ = alternatives($1, $3);
    }
|
    _optMs_regex
;

_block:
    BLOCK
    {
        block();
    }
;

_regex_list:
    _regex_list ORNL nl_reset _regex_list  // after ORNL continue parsing
    {                                       // at a new line
        $$ = alternatives($1, $3);
    }
|
    regex
;

_msBlock_rule_def:
    // empty
|
    _regex_list 
    {
        //addRule($1);
    }        
|
    _regex_list _block    
    {
        //addBlockRule($1);
    }
|
    eof_pattern
;


    // each rule ends in a '\n'
_msBlock_rule:                      
    _msBlock_rule_def '\n' nl_reset
;                               
                                

_msBlock_rules:
    _msBlock_rules _msBlock_rule
|
    // empty
;

_ms_block:
    ms_spec '{' _msBlock_rules _msBlock_rule_def '}'
    {   // following a ms_block, reset the startconditions to 'INITIAL'
        d_rules.resetStartConditions();
    }
;

_rule_def:
    // only an empty line is OK
|
    // recovery from errors is OK: continue at the next line
    error       
|
        // just regular expressions, without an action block
    _optMs_regex_list 
    {
        //addRule($1);
    }
|
        // the scanner returns a block if it encounters a non-blank character
        // on a line after ws, unless the character is a '|'
    _optMs_regex_list _block    
    {
        //addBlockRule($1);
    }
|
    _ms_block
|
    eof_pattern
;

    // each rule ends in a '\n'
_rule:                      
    _rule_def '\n' nl_reset
;                               
                                
    // there may be no rules
    // the scanner skips blanks, but returns '\n'
rules:
    rules _rule
|
    // empty
;
