_ms_name:
    identifier
    {
        d_rules.activateStartCondition($1);
    }
;

_ms_list:
    _ms_list ',' _ms_name
|
    _ms_name
;

_ms_specs:
    '*'
    {   // following <*> all mini scanners apply
        d_rules.useAll();
    }    
|
    _ms_list
;

_ms:
    '<' _ms_specs '>' 
;

    // elements may need to be split between _cc_element and _simple_regex
    // if their handling turns out to be special
_combi_chars:
    ','
|
    '='
|
    '-'
|
    '\''
;

_decimal:
    DECIMAL
    {
        $$ = SemUnion(d_matched);
    }
;

_interval:
    _decimal
    {
        $$ = SemUnion(Interval::exact($1->value<TEXT>()));
    }
|
    _decimal ',' _decimal
    {
        $$ = SemUnion(Interval::range($1->value<TEXT>(), 
                                      $3->value<TEXT>()));
    }
|
    _decimal ','
    {
        $$ = SemUnion(Interval::lowerBound($1->value<TEXT>()));
    }
;
    

_quantifier:
    '*'
|
    '+'
|
    '?'
;

_m_contents:
    {
        d_msg = "character class";
    }
;

_cc_start:
    CC_START
    _m_contents
    {
        $$ = setElements(1);   // skips the opening bracket
    }
;

_cc_negated:
    CC_NEGATED
    _m_contents
    {
        $$ = setElements(2);   // skips bracked and negation caret
    }
;

_cc_end:
    ']'
    {
        d_msg = "pattern or action block";
    }
;

    // characters handled identically within a character-set
_cc_literal:
    '/'
|
    '|'
|
    '('
|
    ')'
|
    '*'
|
    '+'
|
    '?'
|
    '{'
|
    '}'
|
    '<'
|
    '>'
|
    '['
|
    '.'
|
    '^'
|
    '$'
|
    DECIMAL
|
    IDENTIFIER
|
    CHAR
|
    STRING
|
    _combi_chars
;

_cc_element:
    ESCAPE_SEQUENCE
    {
        $$ = CharClass::escape(d_matched);
    }
|
    PREDEFINED_CLASS
    {
       $$ = CharClass::predefined(d_matched);
    }
|
    _cc_literal
    {
        $$ = setElements();
    }
;

_cc_contents:
    _cc_contents _cc_element
    {
        $$ = setConcatenate($1, $2);
    }
|
    _cc_element
;

_cc_set:
    _cc_start _cc_contents _cc_end
    {
        $$ = setConcatenate($1, $2);
    }
|
    _cc_negated _cc_contents _cc_end
    {
        $$ = setNegate($1, $2);
    }
;

_characterclass:
    _characterclass CC_PLUS _characterclass
    {
        $$ = unite($1, $3);
    }
|
    _characterclass CC_MINUS _characterclass
    {
        $$ = difference($1, $3);
    }
|
    _cc_set
;

 
_multi_char:
    DECIMAL
|
    IDENTIFIER
;

_single_char:
    CHAR
|
    _combi_chars
;

_open_paren:
    '('
    {
        ++d_parentheses;
    }
;

_close_paren:
    ')'
    {
        --d_parentheses;
    }
;

    // a _simple_regex is a regular expression, not having a LA operator
    // It may have ^ and $ symbols
_simple_regex:
    '^'
    {
        $$ = boln();
    }
|
    '$'
    {
        $$ = dollar();
    }
|
    STRING
    {                                                   
        $$ = str();
    }
|
    QUOTES
    {                                                   
        $$ = quotes();
    }
|
    _multi_char
    {
        $$ = head();
    }
|
    _single_char
    {                                                   
        $$ = rawText();
    }
|
    ESCAPE_SEQUENCE
    {
        $$ = escape();
    }
|
    '.'
    {
        $$ = dot();
    }
|
    _simple_regex _simple_regex           %prec CHAR
    {
        $$ = concatenate($1, $2);
    }
|
    _simple_regex '|' _simple_regex
    { 
        $$ = alternatives($1, $2);
    }
|
    _open_paren _simple_regex _close_paren
    {
        $$ = $2;
    }
|
    _simple_regex _quantifier
    {
        $$ = quantifier($1);
    }
|
    _simple_regex '{' _interval '}'
    {
        $$ = interval($1, $3);
    }
|
    _characterclass
    {
        $$ = SemUnion(PatternVal());
    }
;


    // a _regex is a regex, possibly with LA operator
    // the handler must verify whether the regex contains ^ and $ symbols
    // within the regex, for which a warning must be issue: ^, $ treated as
    // normal characters
_regex:
    _simple_regex
|
    _simple_regex '/' _simple_regex 
    {
        $$ = lookahead($1, $3);
    }
;

        // regex in the form: <miniscanner>(opt) regex
_optMs_regex:       
    _ms _regex
    {   // following a <ms>regex, reset the ms back to INITIAL
        d_rules.resetStartConditions();
    }
|
    _regex
;

    // series of _optMs_regexes, separated by '|' at the end of lines. E.g.,
    // _optMs_regex1   |
    // _optMs_regex2   |
    // _optMs_regex3
    // (ORNL is returned at '| {OPTBL} \n')
    // at ORNL any previously set ms-spec ends, and is back to INITIAL
_optMs_regex_list:
    _optMs_regex_list ORNL _optMs_regex_list // TODO: after ORNL begin parsing
    {                                        // at a new line
        $$ = alternatives($1, $3);
    }
|
    _optMs_regex
;

_block:
    BLOCK
    {
        block();
    }
;

_regex_list:
    _regex_list ORNL _regex_list        // TODO: after ORNL begin parsing
    {                                   // at a new line
        $$ = alternatives($1, $3);
    }
|
    _regex
;

_eof_pattern:
    EOF_PATTERN
    {
        addRule(eofPattern());
    }
        
|
    EOF_PATTERN _block
    {
        addBlockRule(eofPattern());
    }
;

_msBlock_rule_def:
    // empty
|
    _regex_list 
    {
        addRule($1);
    }        
|
    _regex_list _block    
    {
        addBlockRule($1);
    }
|
    _eof_pattern
;


    // each rule ends in a '\n'
_msBlock_rule:                      
    _msBlock_rule_def '\n'       
;                               
                                

_msBlock_rules:
    _msBlock_rules _msBlock_rule
|
    // empty
;

_ms_block:
    _ms '{' _msBlock_rules _msBlock_rule_def '}'
    {   // following a ms_block, reset the startconditions to 'INITIAL'
        d_rules.resetStartConditions();
    }
;

_rule_def:
    // only an empty line is OK
|
    // recovery from errors is OK: continue at the next line
    error       
|
        // just regular expressions, without an action block
    _optMs_regex_list 
    {
        addRule($1);
    }
|
        // the scanner returns a block if it encounters a non-blank character
        // on a line after ws, unless the character is a '|'
    _optMs_regex_list _block    
    {
        addBlockRule($1);
    }
|
    _ms_block
|
    _eof_pattern
;

    // each rule ends in a '\n'
_rule:                      
    _rule_def '\n'       // TODO: reset the parser to begin-of-rule
;                               
                                
    // there may be no rules
    // the scanner skips blanks, but returns '\n'
rules:
    rules _rule
|
    // empty
;
