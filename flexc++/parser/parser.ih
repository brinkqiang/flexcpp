// Generated by Bisonc++ V2.09.04 on Mon, 16 Jan 2012 21:40:37 +0100

    // Include this file in the sources of the class Parser.

// $insert class.h
#include "parser.h"

    // Add below here any includes etc. that are only 
    // required for the compilation of Parser's sources.
#include <bobcat/arg>
#include <bobcat/mstream>
#include <bobcat/string>

#include "../options/options.h"
#include "../state/state.h"

#include "../semunion/semunion.h"

#include "../rules/rules.h"

using namespace std;
using namespace FBB;

inline spSemUnion Parser::str()
{
    return rawText(String::unescape(
                           d_matched.substr(1, d_scanner.length() - 2)));
}

inline spSemUnion Parser::escape()
{
    spSemUnion ret(Pattern::escape(d_states, d_matched));
    return ret;
}

inline spSemUnion Parser::rawText()
{
    spSemUnion ret(Pattern::rawText(d_states, d_matched));
    return ret;
}

inline spSemUnion Parser::rawText(string const &str)
{
    spSemUnion ret(Pattern::rawText(d_states, str));
    return ret;
}

inline spSemUnion Parser::dot()
{
    spSemUnion ret(Pattern::dot(d_states));
    return ret;
}

inline spSemUnion Parser::alternatives(spSemUnion const &lhs, 
                                       spSemUnion const &rhs)
{
    return Pattern::alternatives(
                            d_states,
                            lhs->value<PATTERN>(),
                            rhs->value<PATTERN>());
}
    
inline spSemUnion Parser::quantifier(spSemUnion const &regex)
{
    return Pattern::quantifier(d_states, 
                            regex->value<PATTERN>(),
                            d_matched[0]);
}
    
inline spSemUnion Parser::interval(spSemUnion &regex, 
                                   spSemUnion const &interval)
{
    return Pattern::interval(d_states, 
                            regex->value<PATTERN>(),
                            interval->value<INTERVAL>());
}
    
inline spSemUnion Parser::unite(spSemUnion const &lhs, spSemUnion const &rhs)
{
    return CharClass::unite(lhs->value<CHARCLASS>(), rhs->value<CHARCLASS>());
}
    
inline spSemUnion Parser::difference(spSemUnion const &lhs, 
                                     spSemUnion const &rhs)
{
    return CharClass::difference(lhs->value<CHARCLASS>(), 
                                 rhs->value<CHARCLASS>());
}
    
inline spSemUnion Parser::setElements(size_t skip)
{
    return CharClass::elements(d_matched, skip);
}
    
inline spSemUnion Parser::setConcatenate(spSemUnion &lhs, 
                                         spSemUnion const &rhs)
{
    return CharClass::concatenate(lhs->value<CHARCLASS>(), 
                                  rhs->value<CHARCLASS>());
}

inline spSemUnion Parser::setNegate(spSemUnion &lhs, spSemUnion const &rhs)
{
    return CharClass::negate(lhs->value<CHARCLASS>(), 
                             rhs->value<CHARCLASS>());
}

inline spSemUnion Parser::characterClass(spSemUnion &charClass)
{
    return Pattern::characterClass(d_states, charClass->value<CHARCLASS>());
}

inline void Parser::assignBlock()
{
    d_rules.assignBlock(d_block);
}

inline void Parser::addBlockRule(spSemUnion const &rule)
{
    d_rules.add(false, rule->value<PATTERN>(), d_block);
}

inline void Parser::noActions()
{
    d_rules.noActions();
}

