// Generated by Bisonc++ V2.09.04 on Mon, 16 Jan 2012 21:40:37 +0100

    // Include this file in the sources of the class Parser.

// $insert class.h
#include "parser.h"

    // Add below here any includes etc. that are only 
    // required for the compilation of Parser's sources.
#include <bobcat/mstream>
#include <bobcat/string>
#include <bobcat/a2x>

#include "../options/options.h"
#include "../state/state.h"

// #include "../semunion/semunion.h"

#include "../rules/rules.h"

using namespace std;
using namespace FBB;

inline Pattern Parser::rawText()
{
    return Pattern::rawText(d_states, d_matched);
}

inline Pattern Parser::rawText(string const &str)
{
    return Pattern::rawText(d_states, str);
}


inline Pattern Parser::eofPattern()
{
    return Pattern::eof(d_states);
}

inline Pattern Parser::str()
{
    return rawText(String::unescape(
                           d_matched.substr(1, d_scanner.length() - 2)));
}

inline Pattern Parser::escape()
{
    return Pattern::escape(d_states, d_matched);
}

inline Pattern Parser::dot()
{
    return Pattern::dot(d_states);
}

inline Pattern Parser::alternatives(Pattern const &lhs, Pattern const &rhs)
{
    return Pattern::alternatives(d_states, lhs, rhs);
}
    
inline Pattern Parser::quantifier(Pattern const &regex)
{
    return Pattern::quantifier(d_states, regex, d_matched[0]);
}
    
inline CharClass Parser::unite(CharClass const &lhs, CharClass const &rhs)
{
    return CharClass::unite(lhs, rhs);
}
    
inline CharClass Parser::difference(CharClass const &lhs, 
                                    CharClass const &rhs)
{
    return CharClass::difference(lhs, rhs);
}
    
inline CharClass Parser::setElements(size_t skip)
{
    return CharClass::elements(d_matched, skip);
}
    
inline Pattern Parser::concatenate(Pattern const &lhs, Pattern const &rhs)
{
    return Pattern::concatenate(d_states, lhs, rhs);
}

inline CharClass Parser::setNegate(CharClass &lhs, CharClass const &rhs)
{
    return CharClass::negate(lhs, rhs);
}

inline CharClass Parser::setNegate(CharClass &lhs)
{
    return CharClass::negate(lhs, CharClass());
}

inline Pattern Parser::characterClass(CharClass const &charClass)
{
    return Pattern::characterClass(d_states, charClass);
}

inline void Parser::assignBlock()
{
    d_rules.assignBlock(d_block);
}

inline void Parser::addBlockRule(Pattern const &rule)
{
    d_rules.add(false, rule, d_block);
}

inline void Parser::noActions()
{
    d_rules.noActions();
}

inline void Parser::orAction()
{
    d_rules.setOrAction();
}
