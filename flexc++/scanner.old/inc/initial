    // The top-level rules for recognizing directives
    // The ^ requirement was relaxed: no clear need to require
    // %-directives to begin at column 1

<INITIAL>{

    {NAME}[[:blank:]]*      return Parser::NAME;
    
    %baseclass-header       {
                                return begin(StartCondition__::option,
                                                Parser::BASECLASSHEADER);
                            }
    %class-header           {
                                return begin(StartCondition__::option,
                                                Parser::CLASSHEADER);
                            }
    %class-name             {
                                return begin(StartCondition__::option,
                                                Parser::CLASSNAME);
                            }
    %debug                  {
                                return begin(StartCondition__::option,
                                                Parser::DEBUG);
                            }
    %debug-steps            {
                                return begin(StartCondition__::option,
                                                Parser::DEBUG_STEPS);
                            }
    %implementation-header  {
                                return begin(StartCondition__::option,
                                                Parser::IMPLEMENTATIONHEADER);
                            }
    %input-implementation   {
                                return begin(StartCondition__::option,
                                                Parser::INPUTIMPLEMENTATION);
                            }
    %input-interface        {
                                return begin(StartCondition__::option,
                                                Parser::INPUTINTERFACE);
                            }
    %interactive            {
                                return begin(StartCondition__::option,
                                                Parser::INTERACTIVE);
                            }
    %lex-function-name      {
                                return begin(StartCondition__::option,
                                                Parser::LEXFUNCTIONNAME);
                            }
    %lex-source             {
                                return begin(StartCondition__::option,
                                                Parser::LEXSOURCE);
                            }
    %no-lines               {
                                return begin(StartCondition__::option,
                                                Parser::NOLINES);
                            }
    %namespace              {
                                return begin(StartCondition__::option,
                                                Parser::NAMESPACE);
                            }
    %skeleton-directory     {
                                return begin(StartCondition__::option,
                                                Parser::SKELETON_DIRECTORY);
                            }
    "%s"                    return Parser::INCL_START_CONDITION;
    "%x"                    return Parser::EXCL_START_CONDITION;
    
    [[:blank:]]+
}

