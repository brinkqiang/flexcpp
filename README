 Flexc++ was designed after `flex'. Flexc++ offers as compared to flex's C++
option a cleaner class-design.

Flexc++ generates a scanner class that is ready for use, as well as a member
function producing the lexical scanner tokens (lex()). The class can easily be
provided with additional members without the need for polymorphic
functions. Consequently, classes generated by flexc++ have no virtual members
and actually have but one public member: lex(), replacing the old-style flex
and flex++ yylex() function.

Flexc++ offers many options, among which an option to define classes generated
by flexc++ in a separate namespace. This allows developers to define
additional symbols, even outside of the class generated by flexc++, without
encountering name-collision problems. With flexc++, artificial means to
prevent name-collisions, like the yy-conventions used by flex and flex++ are
no longer required.  Flexc++ generates C++ code. If C code is required, flex
should be used. Flexc++'s grammar requirements are highly compatible with
flex's requirements, so converting a flex grammar into a flexc++ grammar
should be fairly simple.

In addition to the flexc++ scanner generator itself and several skeleton
files, the package contains an extensive man-page, as well as a full manual
rewritten after the original flex manual, and several examples.



To create the program from its sources, either descend into the flexc++
directory, or unpack a created archive, cd into its top-level directory 
and follow the instructions provided in the INSTALL file found there.

Alternatively, binary ready-to-install versions of flexc++ are
available in verious Linux distributions, in particular Debian. See, e.g.,
https://packages.debian.org/search?keywords=flexc%2B%2B&searchon=names&suite=all&section=all

Github's web-pages for flexc++ are here:
https://fbb-git.github.io/flexcpp/







